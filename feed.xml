<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://www.lukeschiefelbein.com/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.lukeschiefelbein.com/blog/" rel="alternate" type="text/html" /><updated>2022-11-01T09:47:46-05:00</updated><id>https://www.lukeschiefelbein.com/blog/feed.xml</id><title type="html">Luke / blog</title><entry><title type="html">Five Levels Of (Bioinformatics) Programming</title><link href="https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html" rel="alternate" type="text/html" title="Five Levels Of (Bioinformatics) Programming" /><published>2021-12-01T00:00:00-06:00</published><updated>2021-12-01T00:00:00-06:00</updated><id>https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust</id><content type="html" xml:base="https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html"><![CDATA[<h1 id="level-1-python">Level 1: Python</h1>

<p>Lately I’ve been getting interested in bioinformatics. While most of my statistics and machine learning skills transfer pretty seamlessly to this new domain, I’ve also been learning more bioinformatics by doing <a href="https://rosalind.info/">Rosalind problems</a>. Rosalind is like <a href="https://projecteuler.net/archives">Project Euler</a> with a biology focus. I started out solving the problems in Python, the language I know best.</p>

<p>For example, in the second Rosalind <a href="http://rosalind.info/problems/rna/">problem</a> we’re asked to write a function that transcribes DNA to RNA. Here’s my Python solution:<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># python hand-rolled
</span><span class="k">def</span> <span class="nf">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">"U"</span> <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">'T'</span> <span class="k">else</span> <span class="n">char</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">])</span>
</code></pre></div></div>
<hr />

<h1 id="level-2-rust">Level 2: Rust</h1>

<p>I realized this would be a perfect opportunity to try out <a href="https://www.rust-lang.org/">Rust</a>, which is supposed to make writing extremely fast code safer and easier.</p>

<h3 id="if-you-already-know-what-rust-is-skip-this">If You Already Know What Rust Is, Skip This</h3>

<p>Rust is a “low-level language with high-level abstractions.” It’s supposed to be as fast and as fine-grained as C, but more “ergonomic” (less code to write because of the said high-level abstractions) and also much safer from bugs.</p>

<p>Rust is fast partially because it’s not garbage collected. Instead, the compiler helps you manually manage memory. To this end it requires you, the programmer, to write some extra bookkeeping annotations that say which functions are using which variables and when (so-called “ownership” with “borrowing” and “lifetimes”). I’ve seen this called “semiautomatic memory management” (as opposed to C/C++ which are fully manual; the compiler doesn’t stop you from making mistakes). This is why people often complain about “fighting the compiler” with Rust: it’s always pointing out inconsistencies in your variable management (in addition to all the usual type errors you get from more typical compilers). That said, once something does compile, you should have a memory-safe, robust, and probably very fast program.</p>

<p>There are also other low-level complexities of the language. For example, there is not one <code class="highlighter-rouge">int</code> type but <em>eight</em>, depending on if you want the integer to be signed and how many bits you want to represent it with. One has to understand the basics of stack versus heap memory. Strings are <a href="https://fasterthanli.me/articles/working-with-strings-in-rust">very complicated</a>. And so on.</p>

<p>The <a href="https://doc.rust-lang.org/book/">Rust book</a> is a great resource for learning the language. Rust has a steep learning curve, but I’ve also not really done low-level programming before, so a lot of the effort for me was learning <em>that</em>. Overall I’ve found Rust is like bowling with the bumpers: it can be maddening to be always bouncing back and forth down the lane, but eventually I always knock some pins over, as opposed to C++ where I’d probably never trust my code to run in a production environment, especially one as correctness-critical as biology.</p>

<h2 id="rust-transcribe">Rust <code class="highlighter-rouge">.transcribe</code></h2>

<p>The Rust implementation of <code class="highlighter-rouge">.transcribe</code> is pretty similar to the Python one (especially since I used Python type hints), except for the <code class="highlighter-rouge">&amp;</code> borrow notation and the <code class="highlighter-rouge">.collect</code> one has to explicitly call on the lazily evaluated <code class="highlighter-rouge">.chars</code> iterator.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// rust hand-rolled</span>
<span class="nd">#[pyfunction]</span>
<span class="k">fn</span> <span class="nf">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">dna</span>
        <span class="nf">.chars</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="sc">'T'</span> <span class="p">{</span> <span class="sc">'U'</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">x</span> <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Additionally, I added the decorator-looking <code class="highlighter-rouge">#[pyfunction]</code> thing (actually a Rust macro) from the <a href="https://github.com/PyO3/pyo3">PyO3 Rust package</a> which makes it really easy to use Rust with Python<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">2</a></sup>.  You (more or less) just add such a prefix, and then you can call the Rust function from Python like so:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># calling rust functions from python
</span><span class="kn">import</span> <span class="nn">bio_lib_string_rs</span>

<span class="n">dna</span> <span class="o">=</span> <span class="s">"ACTGACTC"</span>
<span class="n">bio_lib_string_rs</span><span class="p">.</span><span class="n">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>
</code></pre></div></div>
<p>Since the Rust version is callable from Python, I could easily wrap both implementations in <a href="https://github.com/cyniphile/rosalind/blob/main/tests/test_benchmark.py">pytest benchmarks</a> for an initial speed test on a ~1000bp DNA string. I got the following results:
<img src="/blog/images/biology-rust/2021-11-09-17-54-55.png" alt="" /></p>

<p>Woot. The Rust version is over 17x faster<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">3</a></sup>, including the overhead of parsing the Python DNA string into a Rust string. I also ran a <a href="https://github.com/cyniphile/rosalind/blob/04885c9644e1cff2287a43dce94763e80f482c39/bio-lib-string-rs/src/lib.rs#L195">pure Rust benchmark on the same data</a> (no Python involved) and Rust was over 50x faster than Python.</p>

<h2 id="more-thorough-performance-comparisons">More Thorough Performance Comparisons</h2>

<p>Now some of you Pythonistas might be foaming at the mouth and swearing at your screen right now, because the way I implemented <code class="highlighter-rouge">transcribe</code> wasn’t very Pythonic. I hand-rolled the following function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># python hand-rolled 
</span><span class="k">def</span> <span class="nf">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">"U"</span> <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">'T'</span> <span class="k">else</span> <span class="n">char</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">])</span>
</code></pre></div></div>

<p>when I could have just used Python’s built-in <code class="highlighter-rouge">.replace</code> function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># python built-in
</span><span class="k">def</span> <span class="nf">transcribe_builtin</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">dna</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">"T"</span><span class="p">,</span> <span class="s">"U"</span><span class="p">)</span>
</code></pre></div></div>

<p>Sure, Rust is a lot faster if we compare apples-to-apples implementations of the same algorithm, but that’s not quite fair in this case because you’d never actually use the hand-rolled implementation in Python, or even Rust for that matter (which also has a built-in <code class="highlighter-rouge">.replace</code>). So I <a href="https://github.com/cyniphile/rosalind/blob/main/tests/test_benchmark.py">benchmarked the built-ins</a> as well:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// rust built-in</span>
<span class="nd">#[pyfunction]</span>
<span class="k">fn</span> <span class="nf">transcribe_builtin</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">dna</span><span class="nf">.replace</span><span class="p">(</span><span class="s">"T"</span><span class="p">,</span> <span class="s">"U"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And also the Python <code class="highlighter-rouge">numpy</code> package built-in:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># numpy 
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">transcribe_np</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">char</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="s">"T"</span><span class="p">,</span> <span class="s">"U"</span><span class="p">))</span>  <span class="c1"># type: ignore
</span></code></pre></div></div>
<p>I also set up some <a href="https://github.com/cyniphile/rosalind/blob/f8f0c3b89a34f269cdbce05e74fed93c198ace35/bio-lib-string-rs/src/lib.rs#L213">separate benchmarks</a> of the Rust functions called directly in Rust, no Python or PyO3 involved. Here are the results on the 1kbp file:</p>

<p><img src="/blog/images/biology-rust/2021-11-09-18-22-16.png" alt="" /></p>

<p>The Python built-in <code class="highlighter-rouge">.replace</code> function is actually the fastest by far. It’s over twice as fast as my Rust function and the Rust <code class="highlighter-rouge">.replace</code> built-in.</p>

<p>This sort of makes sense since Python’s <code class="highlighter-rouge">.replace</code> is actually just <a href="https://github.com/python/cpython/blob/5f9247e36a0213b0dcfd43533db5cf6570895cfd/Objects/stringlib/transmogrify.h#L678">a highly optimized C function</a>, though it’s still surprising that the Rust <code class="highlighter-rouge">.replace</code> built-in is a lot slower<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">4</a></sup>.</p>

<p>The same ranking holds over different sizes of data, though Numpy seems to eventually overcome some fixed initialization overhead.</p>

<p><img src="/blog/images/biology-rust/2021-11-09-17-27-36.png" alt="" />
This plot was made using a <a href="https://github.com/nschloe/perfplot">perfplot</a>-based Python script, so the pure Rust functions weren’t included.</p>

<h2 id="actually-speeding-something-up">Actually Speeding Something Up</h2>

<p>I decided to try out a more domain-specific bioinformatics task that isn’t already a Python built-in. This next Rosalind problem is to <a href="http://rosalind.info/problems/revp/">identify reverse palindromes</a> in a DNA sequence, Python answer below:<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">5</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">PalindromeLocation</span><span class="p">:</span>
    <span class="n">start_index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">int</span>


<span class="k">def</span> <span class="nf">find_reverse_palindromes</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
    <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">test_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>
                <span class="n">locations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">PalindromeLocation</span><span class="p">(</span><span class="n">start_index</span><span class="o">=</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">locations</span>


<span class="k">def</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">reverse_complement_dna</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">reverse_complement_dna</span><span class="p">(</span><span class="n">dna_seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">dna_base_complement</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">dna_seq</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>


<span class="k">def</span> <span class="nf">dna_base_complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> 
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"A"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"T"</span>
    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"T"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"A"</span>
    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"G"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"C"</span>
    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"C"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"G"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">"Non-DNA base </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> found."</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
</code></pre></div></div>

<p>The Rust implementation is very similar but uses a more functional style (<code class="highlighter-rouge">.fold</code> instead of an outer <code class="highlighter-rouge">for</code> loop)<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[pyclass]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PalindromeLocation</span> <span class="p">{</span>
    <span class="nd">#[pyo3(get,</span> <span class="nd">set)]</span>
    <span class="k">pub</span> <span class="n">start_index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="nd">#[pyo3(get,</span> <span class="nd">set)]</span>
    <span class="k">pub</span> <span class="n">length</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[pyfunction]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_reverse_palindromes</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">seq</span><span class="nf">.chars</span><span class="p">()</span>
        <span class="nf">.take</span><span class="p">(</span><span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">length</span> <span class="k">in</span> <span class="p">(</span><span class="n">min_len</span><span class="o">..</span><span class="p">(</span><span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">test_seq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)];</span>
                <span class="k">if</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">PalindromeLocation</span> <span class="p">{</span>
                        <span class="n">start_index</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">length</span><span class="p">,</span>
                    <span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">acc</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">seq</span> <span class="o">==</span> <span class="nf">reverse_complement_dna</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">reverse_complement_dna</span><span class="p">(</span><span class="n">dna_seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">dna_seq</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">dna_base_complement</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">dna_base_complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">base</span> <span class="p">{</span>
        <span class="sc">'A'</span> <span class="k">=&gt;</span> <span class="sc">'T'</span><span class="p">,</span>
        <span class="sc">'T'</span> <span class="k">=&gt;</span> <span class="sc">'A'</span><span class="p">,</span>
        <span class="sc">'G'</span> <span class="k">=&gt;</span> <span class="sc">'C'</span><span class="p">,</span>
        <span class="sc">'C'</span> <span class="k">=&gt;</span> <span class="sc">'G'</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Non-DNA base </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> found."</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And I also added a small Python wrapper to map the Rust <code class="highlighter-rouge">PalindromeLocation</code> <code class="highlighter-rouge">struct</code> to the Python <code class="highlighter-rouge">dataclass</code>, which adds more language interface overhead<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_reverse_palindromes_rs</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">bio_lib_string_rs</span><span class="p">.</span><span class="n">find_reverse_palindromes</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span> 
        <span class="n">PalindromeLocation</span><span class="p">(</span>
            <span class="n">start_index</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">start_index</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">length</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span> 
    <span class="p">]</span>
</code></pre></div></div>

<p>I also made a Python implementation that uses Numpy arrays <a href="https://github.com/cyniphile/rosalind/blob/04885c9644e1cff2287a43dce94763e80f482c39/bio-lib-py/bio_lib_py/bio_lib.py#L82">(see the repo for details)</a>.</p>

<p>How did things pan out this time?</p>

<p><img src="/blog/images/biology-rust/output.png" alt="" /></p>

<p>Rust is about 15x faster than base Python, even with all the conversion overhead! Was it worth the effort? I’d say “yes!” Writing these relatively simple Rust functions is frankly pretty easy (though Rust definitely can get a lot harder). The PyO3 crate makes it straightforward to incrementally add the extra “Rust thrust” (new viral hashtag?) when you need it. This wasn’t without paper-cuts or head-scratchers, but if this was for heavily reused code (part of a data pipeline?), it’s well worth the price of implementation.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">8</a></sup></p>

<hr />

<h1 id="level-3-algebraic-data-types">Level 3: Algebraic Data Types</h1>

<p>So far I’ve just represented DNA as strings. This is bad, and here’s an example of why.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">dna_base_complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">base</span> <span class="p">{</span>
        <span class="sc">'A'</span> <span class="k">=&gt;</span> <span class="sc">'T'</span><span class="p">,</span>
        <span class="sc">'T'</span> <span class="k">=&gt;</span> <span class="sc">'A'</span><span class="p">,</span>
        <span class="sc">'G'</span> <span class="k">=&gt;</span> <span class="sc">'C'</span><span class="p">,</span>
        <span class="sc">'C'</span> <span class="k">=&gt;</span> <span class="sc">'G'</span><span class="p">,</span>
        <span class="c1">// Commented out for now...</span>
        <span class="c1">// _ =&gt; panic!("Non-DNA base \"{}\" found.", base),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This Rust little function, when given a DNA base, returns the complementary base. Note I had to name it <code class="highlighter-rouge">dna_base_complement</code>, because it only works with DNA. If you understand basic biology, you know the output is also DNA (not RNA, or amino acids). However, none of this information is encoded in the logic of the function’s code.</p>

<p>I’ve commented out a line in the code above, and without it, the function actually doesn’t compile. Rust checks pattern matches for exhaustivity, and since <em>any</em> UTF-8 <code class="highlighter-rouge">char</code> can be passed into this function, I have to also handle the case where the <code class="highlighter-rouge">base</code> argument happens to not be “A”, “C”, “T”, or “G”.</p>

<p><img src="/blog/images/biology-rust/2021-11-12-08-45-01.png" alt="" /></p>

<p>So I have to uncomment that last line, which is a catch-all case. Now if I somehow give a non-DNA character to our function at runtime, the program will panic (and crash if the panic isn’t handled). Say I accidentally pass in the RNA character “U”…uh oh! Thankfully I can completely eliminate the possibility of this kind of runtime error using <em>Algebraic Data Types</em> or ADTs.</p>

<p>Algebraic data types are simply types composed of other types. There are two main kinds of ADTs: product types and sum types. A product type is an AND group of types: for example tuples, <code class="highlighter-rouge">struct</code>s, or Python <code class="highlighter-rouge">dataclass</code>es. These are pretty obviously useful: sometimes you need to group diversely typed data together under one type, like a <code class="highlighter-rouge">user</code> type that has string <code class="highlighter-rouge">name</code> AND integer <code class="highlighter-rouge">age</code> fields.</p>

<p>The other common ADT, the sum type, was new to me, but I’ve realized it’s perhaps even more powerful and interesting<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>. A sum type is an XOR group of different types, so an instance can be one (and only one) type out of a set of given options. In Rust you create sum types with the <code class="highlighter-rouge">enum</code> keyword. For example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">DnaNucleotide</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">C</span><span class="p">,</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This defines <code class="highlighter-rouge">DnaNucleotide</code> as a new type that can be one of four variants<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup> <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">C</code>, <code class="highlighter-rouge">G</code>, or <code class="highlighter-rouge">T</code>. Why is this interesting? Well, now I can rewrite my <code class="highlighter-rouge">complement</code> function like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="n">DnaNucleotide</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DnaNucleotide</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">base</span> <span class="p">{</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">T</span><span class="p">,</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">T</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">A</span><span class="p">,</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">C</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">G</span><span class="p">,</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">G</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">C</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note I dropped the <code class="highlighter-rouge">dna_</code> prefix from the function name: I know I’m getting the complement of DNA because the <code class="highlighter-rouge">base</code> argument is of <code class="highlighter-rouge">DnaNucleotide</code> type, and so is the return type. It only accepts DNA, not RNA or “!” or “为” or “🌯”. And if I try to pass in a character I get a <em>compile time</em> error:</p>

<p><img src="/blog/images/biology-rust/2021-11-12-09-45-14.png" alt="" /></p>

<p>We aren’t even allowed to wire <code class="highlighter-rouge">complement</code> up to anything but its proper DNA input. We also get another neat exhaustivity check at compile time if we forget to handle one of the enumerated bases:</p>

<p><img src="/blog/images/biology-rust/2021-11-12-09-40-15.png" alt="" /></p>

<p>This time I don’t have to add the catch-all <code class="highlighter-rouge">_ =&gt; panic!("Non-DNA base \"{}\" found.", base)</code> case because the compiler knows there can only be four different <code class="highlighter-rouge">DnaNucleotide</code> variants, and I’ve properly handled all of them. While this example might seem trivial, what about, say, a function from codons to amino acids? If I forget or duplicate one of the $4^3$ codons (like I did below), the compiler tells us!</p>

<p><img src="/blog/images/biology-rust/2021-11-12-09-49-10.png" alt="" />
Note in this example I’ve made use of <code class="highlighter-rouge">RnaNucleotide</code> and <code class="highlighter-rouge">AminoAcid</code> enums that I defined <a href="https://github.com/cyniphile/rosalind/blob/main/bio-lib-algebraic-rs/src/lib.rs">elsewhere in the code</a>.</p>

<p>This is also useful for easily adapting the software to work with <a href="https://en.wikipedia.org/wiki/Alloprotein#:~:text=An%20alloprotein%20is%20a%20novel,non%2Dnatural%22%20amino%20acids.&amp;text=The%20usual%20mechanisms%2C%20which%20produce,novel%20proteins%20the%20same%20way.">alloproteins</a> (proteins with non-natural amino acids) or <a href="https://en.wikipedia.org/wiki/D5SICS">artificial base pairs</a>. All I’d have to do is add another symbol to the “AminoAcid” or “DnaNucleotide” enums, and then a bunch of exhaustivity checking compiler errors will pop up wherever I now need to handle the new variant types.</p>

<h2 id="speed">Speed</h2>

<p>Does all this organizational overhead make our code perform less efficiently? Well, theoretically it could actually make it more efficient. Strings (in both Rust and Python) are encoded in UTF-8 which uses a minimum of 8-bits per symbol. DNA has only four symbols and so only really needs 2 bits per base. Another consideration is parsing: if our DNA is saved in a file (say <a href="https://en.wikipedia.org/wiki/FASTA_format">FASTA format</a> which just uses character strings), we have to read the file <em>and</em> parse it into our internal enum representation. This means <a href="https://github.com/cyniphile/rosalind/blob/99c3fdb60985b09e9418b308d9bdae4a7657ecbe/bio-lib-algebraic-rs/src/lib.rs#L86">more code to write</a> and more computational overhead.</p>

<p>I wasn’t sure how the trade-off would play out, so I just benchmarked everything using the excellent <a href="https://github.com/bheisler/criterion.rs">criterion</a> package for Rust. I compared the original string <code class="highlighter-rouge">find_reverse_palindromes</code> function with one that operates on a vector of <code class="highlighter-rouge">DnaNucleotide</code> enums. I also timed the ADT/enum version both including the string-to-enum parsing step, and as a pre-parsed version where I only timed the palindrome searching part. Drumroll…</p>

<p><img src="/blog/images/biology-rust/Schermata-2021-11-16-alle-15.51.28.png" alt="" /></p>

<p>It looks like Rust’s promise of “zero-cost abstractions” is a lie, we are actually getting <em>negative</em> cost abstractions here! Even including the parsing overhead, the ADT-based version of our function is over twice as fast as the string version. The Rust compiler clearly takes advantage of the <code class="highlighter-rouge">enum</code> representation to make some key optimizations (though I couldn’t tell what these optimizations actually are when comparing the <a href="https://github.com/cyniphile/rosalind/blob/main/bio-lib-algebraic-rs/asm_output/find_reverse_palindromes_adt.asm">emitted assembly and LLVM IR</a> of the two functions. I leave that as an exercise for the reader 😃).</p>

<h2 id="what-about-python">What About Python?</h2>

<p>ADTs sort-of <a href="https://stackoverflow.com/questions/16258553/how-can-i-define-algebraic-data-types-in-python">exist in Python</a> while using <code class="highlighter-rouge">mypy</code> typechecking, which even offers hacky-feeling <a href="https://hakibenita.com/python-mypy-exhaustive-checking">exhaustivity checks</a>. However, Enum support is <a href="https://github.com/PyO3/pyo3/issues/834">not quite ready in PyO3</a>, so it’s not yet possible to call enum-based Rust functions from Python. To use Rust in Python, we’ll just have to wrap our ADT-style function with another function that accepts a string and pre-parses it into a vector of enums:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[pyfunction]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_reverse_palindrome_dna</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">seq</span> <span class="o">=</span> <span class="nn">DNA</span><span class="p">::</span><span class="nf">parse_string</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
    <span class="nf">find_reverse_palindromes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>While this hack unfortunately sequesters all the nice ADT-related type checks to the Rust side of the code, at least it allows us to take advantage of the speed boost of using enums in Python.</p>

<hr />

<h1 id="level-4-parallelize">Level 4: Parallelize</h1>

<p>So far I’ve been ignoring one of the most important speed factors in modern programming: parallelism. It’s always slightly painful to see my six-core Intel i7 running at, well, 1/6 capacity!</p>

<p>I decided to try out the newish <a href="https://github.com/ray-project/ray">ray</a> package to parallelize my Python function<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">11</a></sup>.  The code for finding reverse palindromes ended up being reasonably similar to the single-threaded version, though it requires an extra <code class="highlighter-rouge">BATCH_SIZE</code> parameter which needs be tuned to optimally slice up work into chunks:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ray</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>


<span class="k">def</span> <span class="nf">find_reverse_palindromes_par</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
    <span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ray_seq</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>  <span class="c1"># type: ignore
</span>
    <span class="o">@</span><span class="n">ray</span><span class="p">.</span><span class="n">remote</span>  <span class="c1"># type: ignore
</span>    <span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ray_seq</span><span class="p">)</span>  <span class="c1"># type: ignore
</span>        <span class="n">locations_inner</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">BATCH_SIZE</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c1"># type: ignore
</span>                    <span class="k">continue</span>
                <span class="n">test_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)]</span>  <span class="c1"># type: ignore
</span>                <span class="k">if</span> <span class="n">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>  <span class="c1"># type: ignore
</span>                    <span class="n">locations_inner</span><span class="p">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">PalindromeLocation</span><span class="p">(</span><span class="n">start_index</span><span class="o">=</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">locations_inner</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BATCH_SIZE</span><span class="p">):</span>
        <span class="n">locations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_palindrome</span><span class="p">.</span><span class="n">remote</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">functools</span><span class="p">.</span><span class="nb">reduce</span><span class="p">(</span> <span class="c1"># flatten list of list
</span>        <span class="n">operator</span><span class="p">.</span><span class="n">iconcat</span><span class="p">,</span> <span class="n">ray</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">locations</span><span class="p">),</span> <span class="p">[]</span>  <span class="c1"># type: ignore
</span>    <span class="p">)</span>
</code></pre></div></div>
<p>Now let’s run this and take a look at our CPU monitor:</p>

<p><img src="/blog/images/biology-rust/2021-11-24-16-46-34.png" alt="" />
Yeah baby! All six cores fully engaged sir!</p>

<p>Parallelizing the Rust code turned out to be the first case where implementation is actually easier in Rust than in Python thanks to the excellent <a href="https://github.com/rayon-rs/rayon">rayon</a> package:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_reverse_palindromes_par</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">DNASlice</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">seq</span><span class="nf">.into_par_iter</span><span class="p">()</span>
        <span class="nf">.take</span><span class="p">(</span><span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">,</span> <span class="p">|</span><span class="k">mut</span> <span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">length</span> <span class="k">in</span> <span class="p">(</span><span class="n">min_len</span><span class="o">..</span><span class="p">(</span><span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">test_seq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)];</span>
                <span class="k">if</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">PalindromeLocation</span> <span class="p">{</span>
                        <span class="n">start_index</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">length</span><span class="p">,</span>
                    <span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">acc</span>
        <span class="p">})</span>
        <span class="nf">.reduce</span><span class="p">(</span>
            <span class="nn">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">,</span>
            <span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span><span class="p">|</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span><span class="nf">.concat</span><span class="p">(),</span>
        <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s as simple as changing <code class="highlighter-rouge">.iter</code> to <code class="highlighter-rouge">.into_par_iter</code> and adding a <code class="highlighter-rouge">.reduce</code> function at the end to stitch together all the asynchronously returned results. Of course, it also needed to be wrapped in similar Python→string→enum/ADT wrapper functions to be useable from Python.</p>

<p>So now it’s time for the final showdown. How do all these “levels” compare speed-wise?</p>

<p><img src="/blog/images/biology-rust/2021-11-23-22-01-06.png" alt="" />
Remember these results are all calls from Python.</p>

<p>While both parallel implementations are slower for smaller inputs (as expected), the Python version is <em>much</em> slower, and it eventually returns to being slower than sequential Python. This was because the <code class="highlighter-rouge">BATCH_SIZE</code> parameter needed some tuning, and after some tedious brute force experimentation, I ended up finding a slightly better value (that was still slower than single-threaded Rust). However Rust’s <code class="highlighter-rouge">rayon</code> performed excellently out of the box thanks to its built-in dynamic performance tuning.</p>

<p>It’s neat to see the performance gains for each of our “levels” of code improvement. In the end, I made my code safer, better organized, <em>and</em> faster by nearly two orders of magnitude. The overhead of learning Rust is certainly high, but hey, I’m already over that hump!</p>

<hr />

<h1 id="level-5">Level 5?</h1>

<p>To avoid publication bias, I admit I also tried a “Level 5” improvement by using iterators more heavily. But, well, gather round…</p>

<p>I was discussing this project with a hacker friend who suggested modifying my functions to return iterators instead of vectors. This way, I could chain together various transformation functions lazily and only call <code class="highlighter-rouge">.collect</code> when needed. The compiler could then optimize the entire chain of transformations top to bottom instead of being forced to collect into vector at each step. Since I’m a data scientist with a Spark background, this suggestion made a lot of sense.</p>

<p>This is where implementing things in Rust got incredibly tricky, and frankly very unproductive. I had to switch over to Rust’s nightly build to be able to make use of experimental typing features. I had to rewrite one line functions as 25-line home-made iterator implementations. I had to really get in the mud with lifetimes, traits, and generics, leading to function signatures like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">transcribe</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">DnaIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">RnaNucleotide</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span>
<span class="k">where</span>
    <span class="n">DnaIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="n">seq</span><span class="nf">.map</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="nf">transcribe_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the end, my code was much <em>less</em> clean, though I could have possibly made it cleaner by using performance-sapping dynamic dispatch<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">12</a></sup>.</p>

<p>I should have stopped and benchmarked sooner, but instead I struggled to port the entire set of bioinformatics functions I’d written so far to this iterators based implementation. <a href="https://github.com/cyniphile/rosalind/blob/main/bio-lib-rs/src/lib.rs">The entire monstrosity is available here</a>. And yes, in the end, the code was significantly (~10%) slower. See one benchmark below:</p>

<p><img src="/blog/images/biology-rust/2021-11-24-16-12-39.png" alt="" /></p>

<p>It would have needed to be a lot faster to justify all the extra work and codebase messiness. Given it was pretty hard to find examples of people using this iterator pattern online, I’m guessing it’s pretty much an anti-pattern. The Rust compiler is clearly worse at optimizing code written this way. In the Rust community, there’s a lot of talk about “idiomatic” code, and I see the value. Unless you’re fluent in assembly and compilers (I’m not), just writing Rust idiomatically seems like an important heuristic for also getting performant Rust. In this case, I violated a universal idiom of all programming languages: “if you’re writing lots of complicated code to do simple things, you’re probably doing it wrong.”</p>

<p>I guess 4 levels of improvement was enough…</p>

<h1 id="tldr">TL;DR</h1>

<ul>
  <li>Rust is faster than Python, but not necessarily for very simple things.</li>
  <li>It’s pretty easy to incrementally add fast Rust functions to an existing Python codebase.</li>
  <li>Use algebraic data types like <code class="highlighter-rouge">enum</code>s instead of strings. ADT-based code is cleaner, safer, and faster.</li>
  <li>Parallelization is important, and it’s easy(er) to do in Rust.</li>
  <li>Benchmark, don’t theorize. <a href="https://github.com/flamegraph-rs/flamegraph#humans-are-terrible-at-guessing-about-performance">“Humans are terrible at guessing about performance!”</a></li>
  <li>Writing Rust simply and idiomatically will probably result in the fastest code (as well as the cleanest).</li>
</ul>

<p>Special thanks to <a href="https://github.com/jgavris">@jgavris</a> of <a href="https://github.com/jgavris/rs-git-fsmonitor">rs-git-fsmonitor</a> fame for various tips and pointers on this post.</p>

<h1 id="notes">Notes</h1>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:3" role="doc-endnote">
      <p>DNA sequence data are stored as the coding strand (not the template strand), so “transcription” really does mean “replace T with U” not “find the RNA complement strand” <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>For a more detailed tutorial <a href="https://depth-first.com/articles/2020/08/10/python-extensions-in-pure-rust-with-pyo3/">see this guide</a>. Installing and using PyO3 had some paper-cuts:</p>
      <ul>
        <li>I needed to add <a href="https://stackoverflow.com/questions/28124221/error-linking-with-cc-failed-exit-code-1">a mysterious config</a> to get it to compile on Mac:</li>
        <li>The VSCode <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">rust-analyzer</a> has a bug where it <a href="https://github.com/rust-analyzer/rust-analyzer/issues/6716">shows</a> fake <a href="https://stackoverflow.com/questions/65223576/what-does-the-rust-analyzer-error-could-not-resolve-macro-crateformat-args">errors</a> in PyO3 macros.</li>
        <li>With PyO3 installed, my project began to show some of Rust’s infamous slow compile times (it went from a couple of seconds ~22s).</li>
      </ul>
      <p><a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>It’s important to use the super-optimized (and slow compiling) <code class="highlighter-rouge">--release</code> flag here. Otherwise, Rust compiles using the default fast-compiling/slow-performing <code class="highlighter-rouge">--debug</code> setting. Check out the performance difference for the <code class="highlighter-rouge">transcribe</code> function: <img src="/blog/images/biology-rust/2021-11-09-12-46-33.png" alt="" /> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Perhaps this is because CPython is compiled with gcc, <a href="https://news.ycombinator.com/item?id=20944403">which can sometimes emit faster instructions than Rust’s LLVM-based compiler</a>. Or perhaps something else; I didn’t look into it too closely. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Yes, I know, this is not the best algorithm. That’s not the point. The point is to compare the same algorithm in Rust and Python. Side note: I wanted to try out Python 3.10’s new <a href="https://www.python.org/dev/peps/pep-0636/">pattern matching</a>, but I couldn’t install some dependencies (SciPy), so I had to go back to version 3.9. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>This was the first time I ran into not-so-nice problems with PyO3. I started with a Rust implementation <a href="https://github.com/cyniphile/rosalind/blob/04885c9644e1cff2287a43dce94763e80f482c39/bio-lib-string-rs/src/lib.rs#L139">nearly identical to the Python one</a> but I ran into a weird GIL deadlock when benchmarking with <code class="highlighter-rouge">perfplot</code> (which apparently does some multithreaded stuff). I managed to resolve this by not having any <code class="highlighter-rouge">mut</code> or borrowed variables in the function body, but this was a quick hack fix. I have not yet gone deep on the <a href="https://pyo3.rs/v0.15.0/types.html?highlight=gil#gil-lifetimes-mutability-and-python-object-types">GIL and mutability</a> w.r.t. PyO3. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>We could define the Python <code class="highlighter-rouge">dataclass</code> <a href="https://depth-first.com/articles/2020/08/10/python-extensions-in-pure-rust-with-pyo3/">purely in Rust</a>, but I wanted to simulate the effect of adding Rust to an existing Python project, where maybe you don’t want to move a class definition to Rust. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Btw, what about PyPy? I didn’t try it because it still just <a href="https://scikit-learn.org/stable/faq.html#do-you-support-pypy">don’t seem ready</a> as a viable CPython alternative for data science. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p><a href="https://youtu.be/FnBPECrSC7o?t=1867">This talk</a> by Ron Minsky of Jane Street Capital has some really interesting examples of using algebraic data types to write more robust code (using OCaml in the context of securities trading). <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>In Rust, variants of an enum aren’t actually types, so you can’t so something like <code class="highlighter-rouge">fn f(s: DnaNucleotide::A) {}</code>. You also can’t write polymorphic code with enums like so:</p>
      <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Nucleotide</span><span class="p">{</span>
    <span class="n">RnaNucleotide</span><span class="p">,</span>
    <span class="n">DnaNucleotide</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Nucleotide</span><span class="p">)</span> <span class="p">{</span><span class="n">s</span><span class="nf">.complement</span><span class="p">();}</span>
</code></pre></div>      </div>
      <p>even if all the variants in the enum implement a <code class="highlighter-rouge">.complement</code> method. Instead you have to do <a href="https://stackoverflow.com/questions/51188460/how-can-i-structure-destructure-an-enum-of-enums">some wrapper/destructuring stuff</a> (which is pretty messy) or you have to use <a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">trait bounds</a> like so:</p>
      <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Nucleotide</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">complement</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Nucleotide</span><span class="p">)</span> <span class="p">{</span><span class="n">s</span><span class="nf">.complement</span><span class="p">();}</span>
</code></pre></div>      </div>
      <p><a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>I ran into some gotchas, but the <a href="https://docs.ray.io/en/latest/ray-design-patterns/fine-grained-tasks.html">tutorials</a> were generally helpful. <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>I ran into basically every problem listed in <a href="https://depth-first.com/articles/2020/06/22/returning-rust-iterators/">this post</a>. <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="programming" /><category term="rust" /><category term="biology" /><summary type="html"><![CDATA[Applying five levels of supercharging to some bioinformatics code using Rust.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.lukeschiefelbein.com/blog/images/biology-rust/2021-11-12-09-45-14.png" /><media:content medium="image" url="https://www.lukeschiefelbein.com/blog/images/biology-rust/2021-11-12-09-45-14.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">The State That Commits More Election Fraud Than Michigan (By One Popular Metric)</title><link href="https://www.lukeschiefelbein.com/blog/election%20fraud/politics/2020/11/12/voter-fraud.html" rel="alternate" type="text/html" title="The State That Commits More Election Fraud Than Michigan (By One Popular Metric)" /><published>2020-11-12T00:00:00-06:00</published><updated>2020-11-12T00:00:00-06:00</updated><id>https://www.lukeschiefelbein.com/blog/election%20fraud/politics/2020/11/12/voter-fraud</id><content type="html" xml:base="https://www.lukeschiefelbein.com/blog/election%20fraud/politics/2020/11/12/voter-fraud.html"><![CDATA[<p><img src="https://www.lavocedinewyork.com/wp-content/uploads/2020/11/democracy-watch.jpg" alt="fraud" title="Photo: New Hampshire Public Radio. https://www.lavocedinewyork.com/wp-content/uploads/2020/11/democracy-watch.jpg" /></p>

<p><em>Note: I have never voted in a Presidential election, and am not registered as a member of any political party</em></p>

<p>“The 2020 election was so…2020”, that’s the tagline we’ve settled on as a nation. Joe Biden’s margin of victory was paper-thin in key states, often thinner than Trump’s margins last election. Of course, those 2016 results were widely claimed to be suspicious, which lead to an investigation that <a href="https://www.justice.gov/storage/report.pdf">uncovered interference from</a> (but <a href="https://taibbi.substack.com/p/russiagate-is-wmd-times-a-million">debunked many widely alleged theories about direct collusion with</a>) Russia.</p>

<div class="table">
<p><strong>Margin of Victory in Key States</strong></p>
<table style="width: 400px">
  <thead>
    <tr>
      <th>&nbsp;</th>
      <th>2020</th>
      <th>2016</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Wisconsin</td>
      <td class="dem">0.62%</td>
      <td class="rep">0.82%</td>
    </tr>
    <tr>
      <td>Michigan</td>
      <td class="dem">2.73%</td>
      <td class="rep">0.24%</td>
    </tr>
    <tr>
      <td>Georgia</td>
      <td class="dem">0.29%</td>
      <td class="rep">5.32%</td>
    </tr>
    <tr>
      <td>Arizona</td>
      <td class="dem">0.35%</td>
      <td class="rep">3.78%</td>
    </tr>
    <tr>
      <td>Pennsylvania</td>
      <td class="dem">0.79%</td>
      <td class="rep">0.75%</td>
    </tr>
  </tbody>
</table>
<p><em>Data Source: New York Times Election Maps</em></p>
</div>

<p>This time it’s the same story, with the party tables turned and the focus on internal voter fraud. The Trump campaign has already <a href="https://www.telegraph.co.uk/news/2020/11/11/what-happening-trump-lawsuit-recounts-postal-votes-us-election-2020/">filed several lawsuits</a> in swing-states alleging election misconduct. Of course, anyone who’s spent time on social media has seen their share of people <a href="https://twitter.com/jackposobiec/status/1325125670599495681?s=10">wondering aloud</a> about the <a href="https://twitter.com/critica18495985/status/1325307257056342016?s=10">integrity</a> of the <a href="https://twitter.com/cernovich/status/1325168281259442184?s=10">election</a>. Meanwhile the New York Times (along with other mainstream media) claims that <a href="https://www.nytimes.com/2020/11/10/us/politics/voting-fraud.html">next-to-zero fraud occurred</a> (which is actually consistent with their <a href="https://www.nytimes.com/2016/12/18/us/voter-fraud.html">2016 views on the matter</a>).</p>

<p>Given the focus on fraud, this election has been busy for hordes of indie data pundits (like me). Some are making <a href="https://twitter.com/monkeyjones1984/status/1325596977602519040?s=10">Deep State connections</a> to hacked election machines, often in connection to the so-called <a href="https://joannenova.com.au/2020/11/cia-programs-designed-to-interfere-in-elections-hammer-and-scorecard/">Hammer and Scorecard</a> CIA election interference software that we’ve allegedly turned against ourselves. Others are just hunting for <a href="https://twitter.com/VC4351/status/1325554847031025665">oddities and anomalies</a>. One analyst made minor news when he raised over $200k via GoFundMe for investigating voting irregularities, only to have <a href="https://www.politico.com/news/2020/11/06/gofundme-removes-conservative-fundraiser-election-misinformation-434800">GoFundMe cancel his campaign</a> citing that he was engaging in “attempts to spread misleading information.”</p>

<p>One data investigation that caught my eye in particular (and the eyes of many others) was that of <a href="https://en.wikipedia.org/wiki/Shiva_Ayyadurai">Dr. Shiva Ayyadurai</a>. Dr. Ayyadurai claims to have invented email<sup id="fnref-1" class="footnote-ref"><a href="#fn-1">1</a></sup>, ran as a Republican for US senator in MA (but lost in primaries), and has almost 200k YouTube subscribers. His latest hour-long video was about a case of possible election fraud in Michigan.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Ztu5Y5obWPk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>In the video, Ayyadurai outlines his team’s analysis of the Michigan counties of Oakland, Macomb, and Kent, where voting data behaves “as though an algorithm was there…that’s what we see here”</p>

<p>The video got a quarter-million views in less than 24 hours. Soon investing legend Michael Burry (Chrisian Bale’s character in <em>The Big Short</em>) was <a href="https://twitter.com/michaeljburry/status/1326416897903128577">retweeting</a>.</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Consider these slides. Worth watching Shiva’s entire presentation for proper context, and deciding for yourself. <a href="https://twitter.com/hashtag/Election2020results?src=hash&amp;ref_src=twsrc%5Etfw">#Election2020results</a> are full of statistical anomalies that do not find easy explanation, but this is one possible explanation. <a href="https://twitter.com/hashtag/Question?src=hash&amp;ref_src=twsrc%5Etfw">#Question</a> <a href="https://twitter.com/hashtag/Election2020?src=hash&amp;ref_src=twsrc%5Etfw">#Election2020</a> <a href="https://t.co/3vpfZzqYUF">pic.twitter.com/3vpfZzqYUF</a></p>&mdash; Michael Burry MD (@michaeljburry) <a href="https://twitter.com/michaeljburry/status/1326416897903128577?ref_src=twsrc%5Etfw">November 11, 2020</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>(He deleted these tweets soon after this article’s writing)</p>

<p>I was intrigued and went down the rabbit hole myself. To get an idea for Ayyadurai’s thesis, you can <a href="https://youtu.be/Ztu5Y5obWPk?t=781">watch his video stating at 13:05</a>, but I’ll also explain his setup below.</p>

<h2 id="straight-ticket-voting-an-electoral-oddity">Straight Ticket Voting: An Electoral Oddity</h2>

<p>Ayyadurai’s analysis centers around an odd aspect of Michigan voting: <a href="https://en.wikipedia.org/wiki/Straight-ticket_voting">straight ticket (or straight party) voting</a>. In a few states, Michigan one of them, you can skip voting for individual candidates for president, senate, congress, and other downballot offices. Instead, you can just check one box to vote for “The Democratic Party” (or “The Republican Party”), which automatically casts your votes to the Democrat (or Republican) candidates for every office on the ballot. It’s basically a “select all” option.</p>

<p><img src="/blog/images/Stright ticket ballot.jpg" alt="" title="A ballot with a 'straight-party' option. https://commons.wikimedia.org/wiki/File:Larsz_-_US_election_08_(by-sa).jpg" /></p>

<p>Ayyadurai’s team created a data visualization by plotting the difference between the straight-ticket voting compared with the regular candidate-by-candidate voting (which I’ll refer to as “mixed-ticket”, since you can mix which parties you vote for when voting in this way). First, they organized precinct voting data as follows:</p>

<table>
  <thead>
    <tr>
      <th>Precinct</th>
      <th>Straight Ticket Votes</th>
      <th>Overall Votes (Straight and Mixed Ticket)</th>
      <th>Difference, Overall vs Straight Ticket</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>precinct 1</td>
      <td>60% Trump</td>
      <td>68% Trump</td>
      <td>8%</td>
    </tr>
    <tr>
      <td>precinct 2</td>
      <td>50% Trump</td>
      <td>48% Trump</td>
      <td>-2%</td>
    </tr>
  </tbody>
</table>

<p>For each precinct in a county, they show (2nd column from the left) what percentage of straight ticket votes went to Trump. Then they calculate how the overall vote went (3rd column from left), and finally look at the difference between the two. They visualize this data with a plot like so (here showing the example data from above):</p>

<p><img src="/blog/images/example_plot.png" alt="" /></p>

<p>Their thesis is that <strong>the straight-ticket voting patterns should be similar to the overall voting patterns</strong>. 
So in a given precinct, if 60% of the straight-ticket votes were for Trump, Ayyadurai pretty reasonably theorizes that around 60% of the mixed party votes should also go to Trump, giving us a flat horizontal line in our plot.</p>

<p>However, when Ayyadurai looked at the actual data from several Michigan counties, he found something much different: <a href="https://youtu.be/Ztu5Y5obWPk?t=1404">a steep and highly significant downward trend</a>, implying that the more Republican a precinct is, the more it tended to flip toward Biden.</p>

<blockquote>
  <p>It looks like his votes counts start getting linearly reduced and if you look at this curve and I’ve looked at lots of curves…anyone of us who’s in the pattern analysis business when you see this…you say something’s up. This is too structured, right? Too perfect.</p>
</blockquote>

<p>He’s right: this level of trend is something that anyone who’s done data science usually loves to see: a very (very) strong correlation between two variables.</p>

<p>What’s going on? This puzzled me too at first. Perhaps it’s caused by “Romney Republicans” that don’t like Trump? Well, Ayyadurai has an answer to that too: if Republicans showed a distaste for Trump, we still ought to see a flat chart, just shifted down. Something else is going on, and for Ayyadurai, the only option left to consider is a malicious algorithm.</p>

<blockquote>
  <p>And remember we’ve talked about it the election systems…they have the feature of being able to manipulate vote counts from one person to another. It’s called a weighted race feature.</p>
</blockquote>

<h2 id="why-are-the-most-republican-precincts-flipping-toward-biden">Why Are The Most Republican Precincts Flipping Toward Biden?</h2>

<p>That problem is, he’s gotten slightly confused about what he’s looking at. We are NOT actually comparing precincts by “how Republican they are”. We are comparing <em>straight-ticket results</em> to overall results. This is a small but very important difference. Why? When someone goes to the polls in Michigan, they first choose to either vote straight-ticket or mixed-ticket. <strong>And they don’t pick randomly</strong>. This is what’s called a <a href="https://en.wikipedia.org/wiki/Selection_bias#:~:text=Selection%20bias%20is%20the%20bias,to%20as%20the%20selection%20effect.">selection bias</a> in data analysis.</p>

<p>The voters that show up to the polls and check the “all Democrats” or “all Republicans” box are, by definition, more partisan voters than the voters that decide to pick and choose between both parties. If a precinct’s straight-ticket votes (the votes from the <em>most</em> partisan voters in the area) go very Trump, then yes, you would expect the definitionally <em>less</em> partisan voters in the area (the mixed-ticket voters) to vote less strongly that way.</p>

<p>But won’t some Biden supporters switch to Trump too? Yes, but not as many, because in a very Republican area Trump would have more to lose and less to gain. Let’s go through a quick example.</p>

<p>Say a precinct has 1000 constituents: 800 Republican, 200 Democrat. If 10% of the Republicans decide to flip, Trump loses 80 votes. If 10% of the Democrats decide to flip, Trump gains 20 votes, for a net loss of 60 votes. Given the selection bias at work, most of these flipping voters are going to do a mixed-ticket vote…if you are a Republican that hates Trump, you probably still want to vote GOP for Senate, etc.</p>

<p><img src="/blog/images/rep precinct example.png" alt="" /></p>

<p>Ayyadurai would say here, 60 votes <em>got moved</em> to Biden. But it’s actually just that mixed-ticket voters are less likely (by definition) to vote with precinct norms, and will tend to move overall results back towards the center.</p>

<p>All of this works the same way for more Democratic precincts; just do the same math but switch “Republican” and “Democrat”, and “Trump” and “Biden”. And if a precinct is split 50/50, there flipping votes net to zero. How does all this look on the precinct plots we’ve been looking at?</p>

<p><img src="/blog/images/all flipping.png" alt="" /></p>

<p>It’s a nice downward sloping line. I’ve only done three data points, but you can see how the rest of the line fills in depending on how Republican or Democrat a precinct is. You can get a steeper line by increasing the percentage of mixed voters that flip (I used a rate of 20% in the example above), or shift the line up or down by making the flip percentage assymentical (e.g. 20% of Republicans flip, but only 10% of Democrats do). Add in some random variation, and this is exactly what we’re seeing in Dr. Shiva’s Michigan chart. It’s theoretically totally normal<sup id="fnref-2" class="footnote-ref"><a href="#fn-2">2</a></sup>.</p>

<h2 id="do-real-elections-actually-work-this-way">Do Real Elections Actually Work This Way?</h2>

<p>So we’ve got ourselves a theory about why these downward trends might exist, no fraud required. Let’s now do what Dr. Shiva didn’t do and look at more data. If our theory is right, we’d expect most counties to show this downward trend, and if Dr. Shiva’s is right, this downward trend should almost never appear.</p>

<p>Remember, only a few states do straight-ticket voting, and it turned out to be either quite a pain or impossible to get at their data. <a href="http://ok.gov/">Ok.gov</a> didn’t seem to work at all, much less have a detailed voting records API. Yikes.</p>

<p>Of course, we do know Michigan’s data is available, so lets take the first minimal step of verification Dr. Shiva didn’t bother to take: look at the same “suspicious” counties in the 2016 election, when Trump won Michigan. Is 2020 really an anomaly? Let’s look at Oakland county in 2016:</p>

<p><img src="/blog/images/Oakland County 2016 small.png" alt="" title="Data: https://results.enr.clarityelections.com/MI/Oakland/63990/184040/en/summary.html." /></p>

<p>It’s the same super statistically significant downward linear trend. It’s not as steep as in 2020, but still equally “suspicious” according to Ayyadurai’s theory. What about the following counties:</p>

<p><img src="/blog/images/randolph.png" alt="" />
<img src="/blog/images/jackson.png" alt="" />
<img src="/blog/images/walker.png" alt="" />
<img src="/blog/images/autauga.png" alt="" />
<img src="/blog/images/geneva.png" alt="" />
<img src="/blog/images/fayette.png" alt="" title="Data: https://www.sos.alabama.gov/alabama-votes/voter/election-data
" /></p>

<p>Do these charts get your pattern researcher taste-buds salivating? Ready to take to the Twitters and yell fraud? Before you do, I should say this is data from Randoph, Jackson, Walker, Autauga, Geneva, and Fayette counties…in Alabama (2016 election)<sup id="fnref-3" class="footnote-ref"><a href="#fn-3">3</a></sup>. This is obviously not the first state that comes to mind when you think of election hacking targets; the state hasn’t voted for a Democrat president since Jimmy Carter in ‘76.</p>

<p>I admit, I cherry-picked some of the “worst” counties above, but the same trend holds throughout. Running Ayyadurai’s analysis on all Alabama counties in 2016, <strong>70% of them showed a negative, statistically significant slope</strong> (in other words β &lt; 0 and p &lt; 0.05). In fact, only 13 of the 67 counties were “normal” by Dr. Shiva’s definition, showing no significant trend either way.</p>

<h2 id="sonow-what">So…Now What?</h2>

<p>Now we are at a crossroads. We’ve got a theory for why such patterns could exist completely legitimately, and the data shows these “suspicious” patterns seem to be the norm.</p>

<p><img src="/blog/images/meme.jpg" alt="" /></p>

<p>I’d go with “there was no fraud” (at least of this kind). Dr. Shiva essentially cooked up a graph of “do mixed-party voters vote less partisan than fully partisan voters?” It’s almost a tautology, and if considered carefully, you’d expect a trend. I don’t know if my explanation is 100% correct, but it’s certainly much better supported by the data than Dr. Shiva’s theory that “trends are anomalous and signify fraud.”</p>

<p>Is Dr. Shiva lying to us then? Probably not. The selection bias he overlooked is easy to miss, and even the best data gurus out there make mistakes in identifying them.</p>

<p>Was Dr. Shiva doing good science and just happened to mess up? No, absolutely not. He and his team didn’t do even the most basic checks to support their theory, i.e. the checks I did above with 2016 election data (by myself in less than a day’s work). Even so, they decided to go ahead and claim there was a clear sign of fraud in Michigan, and publish this to their 200k trusting subscribers. Nothing could be more scientifically irresponsible, especially for a man that claims over and over again to be following the principles of science. Now I’m starting to wonder…did he really invent email?</p>

<p><em>Code and data used to generate this analysis can be <a href="https://github.com/cyniphile/vote-investigation">found on Github</a></em>.</p>

<div class="footnotes"><p id="fn-1">1. The invention of email is generally credited to Ray Tomlinson around 1970, though Ayyadurai does hold <a href="https://techland.time.com/2011/11/15/the-man-who-invented-email/">the first copyright</a> to the term dated 1982.<a href="#fnref-1" class="footnote footnotes">↩</a></p></div>

<div class="footnotes"><p id="fn-2">2. We are making a couple of big assumptions here: 1) that the ratio of split-ticket/mixed-ticket votes is uncorrelated with a precinct's party leaning. 2) that the proportion of voters who flip is uncorrelated with a precinct's party leaning. If either assumption is violated in the right way, you could see flat graphs like Dr. Shiva is showing. Ultimately, we simply need to look to the data to see if graphs with lots of slope are the norm or not.<a href="#fnref-2" class="footnote footnotes">↩</a></p></div>

<div class="footnotes"><p id="fn-3">3. Alabama was the only state I could find with both straight-ticket voting and (sort of) readily available voting data. 2020 data was not yet available at the time of this writing. If you find more, let me know!<a href="#fnref-3" class="footnote footnotes">↩</a></p></div>]]></content><author><name></name></author><category term="election fraud" /><category term="politics" /><summary type="html"><![CDATA[Many Americans believe fraud occurred in the 2020 election, in part due to well-circulated theories on social media. I take a close look at one of the most popular (and seemingly plausible) of these theories.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.lukeschiefelbein.com/blog/images/Stright%20ticket%20ballot.jpg" /><media:content medium="image" url="https://www.lukeschiefelbein.com/blog/images/Stright%20ticket%20ballot.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">The Slant Fueling The Abortion War Must End</title><link href="https://www.lukeschiefelbein.com/blog/abortion/politics/2020/10/20/abortion.html" rel="alternate" type="text/html" title="The Slant Fueling The Abortion War Must End" /><published>2020-10-20T00:00:00-05:00</published><updated>2020-10-20T00:00:00-05:00</updated><id>https://www.lukeschiefelbein.com/blog/abortion/politics/2020/10/20/abortion</id><content type="html" xml:base="https://www.lukeschiefelbein.com/blog/abortion/politics/2020/10/20/abortion.html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/Abortion_Hurts_Women_%2832676869635%29.jpg/1600px-Abortion_Hurts_Women_%2832676869635%29.jpg" alt="abortion" title="Which sign makes you angry? Photo: James McNellis from Washington, DC, United States. https://commons.wikimedia.org/wiki/File:Abortion_Hurts_Women_(32676869635).jpg)" /></p>

<p>Election time is upon us and abortion is both as important and as divisive as ever. The debate over Trump’s nomination of Amy Coney Barret to the Supreme Court revolved heavily around her probable pro-life<sup id="fnref-1" class="footnote-ref"><a href="#fn-1">1</a></sup>  stance. Meanwhile, in the first presidential debate, Joe Biden explicitly left open the possibility of <a href="https://edition.cnn.com/2020/09/30/politics/joe-biden-court-packing/index.html">packing the court</a> in response.</p>

<p>Abortion comes with such a permissive license to righteous anger that most people avoid the festering topic. No wonder a <a href="https://news.gallup.com/poll/1576/abortion.aspx">Gallup poll</a> indicates that in the past 25 years the American people have only gotten more divided on the issue, of late jittering around a 50-50 split between pro-life and pro-choice. Facebook feeds are crawling with memes about Bible-thumping, misogynistic white men, or organ harvesting Mengeles at Planned Parenthood. In the abortion debate, once you choose a side, the 150 million people in this country with the opposing view suddenly become some mix of stupid and Satan.</p>

<p><img src="https://content.gallup.com/origin/gallupinc/GallupSpaces/Production/Cms/POLL/902aelfr70k9wvxxkig2fg.png" alt="abortion split" title="Chart: https://news.gallup.com/poll/1576/abortion.aspx" /></p>

<p>Like all politics, the issue of abortion has suffered from the mainstream media polarization described so well in Matt Taibbi’s book <a href="https://www.amazon.com/Hate-Inc-Todays-Despise-Another/dp/1949017257">Hate Inc.</a> The book’s thesis is simple: hate sells. Rage is no longer just a toxic byproduct of our media; it’s the new unnatural life-blood. Now most publications have morphed from forums of fruitful public discourse into profitable echo chambers.</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">&quot;We live in a time of incredible political division... It’s become difficult to have an argument in the traditional sense. People with differing opinions are often no longer even working from the same commonly-accepted set of facts.&quot; <a href="https://t.co/PBREDO6vgd">https://t.co/PBREDO6vgd</a></p>&mdash; Matt Taibbi (@mtaibbi) <a href="https://twitter.com/mtaibbi/status/1307351126870757381?ref_src=twsrc%5Etfw">September 19, 2020</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Abortion is perhaps the ultimate case study of this communication breakdown. There’s no definitive answer to the issue’s fundamental question “when does a fetus become human?”, however abortion “debate” rarely goes so far as to discuss its own fundamental crux. This couldn’t have been illustrated more perfectly in the 2020 vice-presidential debate, with Kamala Harris proudly showing support for “for a woman’s right to make a decision about her own body” while Mike Pence “couldn’t be more proud to serve as vice president to a president who stands without apology for the sanctity of human life.”</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/_80d95hMjC4?start=386" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Note that this missed connection comes with a district difference in terminology: “make a decision” vs “sanctity of life”. The abortion debate is riddled with such partisan wordplay that reflects each group’s very well-intentioned goals (women’s health vs fetal rights), but they also embody not-so-subtle digs at their opponents. It’s not even possible to reference the parties by name without stirring controversy. If you’re opposed to the “Pro-life” movement, as it calls itself, does that mean you are “not pro-life”? This sounds strange, and so the term “anti-abortion” is used instead, at least by detractors of the movement. By using one set of terminology you unmistakably identify your “side” and immediately either ingratiate yourself with, or aggravate, your audience.</p>

<p>For example this podcast in the New York Times: <a href="https://www.nytimes.com/2020/09/23/podcasts/the-daily/supreme-court-trump-roe-v-wade.html">“An Anti-Abortion Leader on Trump’s Supreme Court Battle”</a> (the title was later changed). A pro-life advocate couldn’t even get past the first two words of the title without feeling slant.</p>

<p>Being a data scientist, I decided to investigate usage of this slanted terminology in a more quantitative way. Knowing that certain terms like “right to life” or “reproductive rights” are almost exclusively partisan and rarely context-dependent, I decided to compile a list of such terms and do a mass search for them in thousands of recent abortion-related news articles (2732 to be exact). By assigning each slanted term a certain weight (“right-to-choose” slants pro-choice, “sanctity of life” slants pro-life) and counting them up, we can uncover which publications lean which way and how strongly. I made the results into an interactive plot below, where you can compare slant across publications and individual articles. You can also customize how terms are weighted based on your personal perception. If you have ideas for other partisan terms, post them in the comments below and I’ll try to add them to the visualization. While this setup is certainly simple<sup id="fnref-2" class="footnote-ref"><a href="#fn-2">2</a></sup>, it nonetheless provides a reasonable high-level picture of the bias extant in journalism today.</p>

<!-- _interactive chart removed temporarily_  -->
<div class="holds-the-iframe"><iframe id="myIframe" src="https://abortion-blog.herokuapp.com/" title="loading interactive plot..."></iframe></div>
<script>
  iFrameResize({ log: true }, '#myIframe')
</script>

<p>Few publications are balanced, and some of the most mainstream papers are very heavy on pro-choice rhetoric. For example, only 25% of articles from the New York Times used a net right-of-center word choice. The Washington Post was much more balanced, and the Bismarck Tribune (from pro-life North Dakota) was extremely right-leaning in its relatively small sample of articles (click on the “Scatter Plot” option to see individual articles).</p>

<p>While partisan writing might function as a call-to-arms for ideological battle, “ideological battle” is an oxymoronic term. The rational brain is suppressed in confrontation, making it almost <a href="https://hbr.org/2015/12/calming-your-brain-during-conflict">physically impossible to change a person’s mind if they sense an attack</a>. The “winner” of such a “battle” is just the one with that last word, not the one who spread his or her message successfully. Is it better to incrementally rally the troops to the polls, or to flip the vast mother-lode of votes in the opposition?</p>

<p>Take the mantra “my body, my choice”. It’s easy to chant and rings proudly of a struggle for individual freedom over the implied oppressive patriarchy. And it misses the point. “It’s not a choice, it’s a child” is the memorized pro-life rebuttal. The pro-life movement is not a cabal of men in Colonel Sanders attire meeting in secret cigar lounges to strategize the next move in white male world dominance. While the religious and traditional culture that is correlated with a pro-life stance is sometimes frustratingly sexist, it’s a causation fallacy to conclude such sexism is fundamental to being pro-life. According to the same <a href="https://news.gallup.com/poll/1576/abortion.aspx">Gallup Poll</a>, 41% of women, 24% of Democrats, and 34% of those who “seldom or never” attend religious services self-describe as “pro-life”–substantial minorities.</p>

<p>But above all, attempts to “prove” that the pro-life movement is hatefully misogynistic are worse than useless: they are inflammatory. Ditto for the pro-life movement’s penchant for portraying pro-choicers as murderous eugenicists<sup id="fnref-3" class="footnote-ref"><a href="#fn-3">3</a></sup> or irresponsible sluts. Humans generally believe themselves to be good people and hold their beliefs for what they perceive as good reasons. Declaring either side (tens of millions of Americans) to be stupid and evil is simplistic and displays a gross lack of empathy, a fundamental quality needed for effective debate and negotiation according to <a href="https://www.masterclass.com/articles/how-to-use-tactical-empathy-to-negotiate">master negotiator Chris Voss.</a> Conversion requires deep trust in the converter; it’s the only way to bypass the deeply instinctual fight-or-flight response that is normal when one’s basic ideals are challenged.</p>

<p>Not every abortion advocate is a screaming nihilist femmenismo with 6-inch gauge earrings (though alt-right Twitter is fond of portraying them as such). And they are not “anti-life” but pro-life with a focus on women’s health. The outcomes of abortion can be enormously beneficial both for women<sup id="fnref-4" class="footnote-ref"><a href="#fn-4">4</a></sup> and their families (by avoiding the obvious physical, emotional, and economic trauma that go with both childbirth) and <a href="https://freakonomics.com/podcast/abortion/">society at large</a>. The cost is ending the existence of a pre-sentient being. Or at least <em>usually</em> pre-sentient.</p>

<p>Ultimately, the moral reasonableness of abortion goes up closer to conception, a fact that pro-lifers won’t admit. And the reasonableness of abortion goes down the closer to birth, a fact pro-choicers won’t admit. This idea of incrementalism was fairly, though crudely, expressed by Josh Zepps on the Joe Rogan podcast:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/F84l0qDi-wQ?start=271" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<blockquote>
  <p>[abortion has] become so polarized in the United States that both positions are bullshit, and people on both sides know that both positions are bullshit. It’s bullshit to say that it is “just a women’s health issue and has no ethical implications whatsoever” even when it’s, as you say, about cutting a woman open at nine months and stabbing the embryo in the head<sup id="fnref-5" class="footnote-ref"><a href="#fn-5">5</a></sup>. It’s also bullshit to say that the instant an egg is fertilized, that is a person that should have all of the rights to life that an adult should have and that it’s murder kill a blastocyst that’s smaller than the size of the head of a pin. Both positions are stupid. This is an incremental situation.</p>
</blockquote>

<p><img src="https://content.gallup.com/origin/gallupinc/GallupSpaces/Production/Cms/POLL/b2mm7nepm0ebj1pxkar6xa.png" alt="timeofabortion" title="Chart: https://content.gallup.com/origin/gallupinc/GallupSpaces/Production/Cms/POLL/b2mm7nepm0ebj1pxkar6xa.png" /></p>

<p>Polls show that nearly <a href="https://news.gallup.com/poll/235469/trimesters-key-abortion-views.aspx">60% of Americans are fine with first-trimester abortions</a>, even though only 46% say they are pro-life. Conversely, only 13% of respondents thought that abortion should be legal in the last trimester. Intuitively, this makes sense: early on the fetus is tiny, doesn’t look that human, and most importantly, can’t feel pain until about 24 weeks gestation. It’s easy to see why pro-life rhetoric often revolves around late-term abortions, a favorite tack of Trump himself.</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Biden and Democrats just clarified the fact that they are fully in favor of (very) LATE TERM ABORTION, right up until the time of birth, and beyond - which would be execution. Biden even endorsed the Governor of Virginia, who stated this clearly for all to hear. GET OUT &amp; VOTE!!!</p>&mdash; Donald J. Trump (@realDonaldTrump) <a href="https://twitter.com/realDonaldTrump/status/1313445293912920064?ref_src=twsrc%5Etfw">October 6, 2020</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>While only a small minority (around 1%) of abortions are later term (post 21 weeks gestation) and the practice is restricted in many states, abortions are indeed federally legal up to the moment of birth for any reason (a system much less restrictive than that of <a href="https://en.wikipedia.org/wiki/Abortion_in_the_United_States_by_state#Current_legal_status_nationwide">most European countries</a>). Additionally, the vast majority of these later-term abortions are <a href="https://onlinelibrary.wiley.com/doi/10.1363/4521013">not for health reasons of the mother or fetus</a>. While women seeking late-term abortions usually have understandable motives for not getting one sooner (such as lack of access, lack of money and insurance, or recent domestic abuse) this does not erase the fact that a life is being ended that is alarmingly human. Interviewed in a <a href="https://youtu.be/a6BEDSohBoY?t=1127">Science Vs</a> podcast, one abortion doctor described the process of “dilation and extraction” (known as “partial-birth abortion” in pro-life lingo) in gory detail, and that “those <a href="https://www.google.com/search?q=dilation+and+extraction+procedure&amp;sxsrf=ALeKk01J0EvU2SLMT-wZAbtyIKHz4PQkCQ:1603732178529&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=2ahUKEwj3gcP239LsAhUjNOwKHdjCCEUQ_AUoAXoECA4QAw&amp;biw=1440&amp;bih=797">posters that anti-abortion groups hold around abortion clinics [link possibly NSFW]</a>, those photos in them can actually be pretty accurate.” Is it really so crazy to be very uneasy with this? When is it right to inflict pain that you cannot feel, to stop a heart that is not yours, on an obviously human form? Is a big quality-of-life improvement a good enough reason?</p>

<p>For example, families that have children with disabilities can have an increased risk of <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4624231/">divorce</a> and increased <a href="https://researchers.mq.edu.au/en/publications/how-much-does-intellectual-disability-really-cost-first-estimates">financial struggle</a>, and disabled children also put a huge financial load on their communities for special education programs and services. From an economic and quality of life perspective, it’s a no-brainer to “terminate” this burden. Now, most pro-choice folks agree “termination” <em>after</em> birth is not morally acceptable at all, but pro-lifers justifiably see the two cases as the same thing. After all, the only difference is a few inches out of the birth canal.</p>

<p>Given the intense moral quandary, is it really beneficial to the pro-choice movement (or even morally sound in general) to die on the hill of federally unrestricted late-term abortion? Conversely, should pro-lifers be willing to die on the hill of limiting access to early-term abortion? While many hold religious beliefs that life is sacred from conception, even if it is just a few cells, is that a reasonable belief to impose on society at large? Could early-term abortions be closer to “a sin that’s legal” like contraception<sup id="fnref-6" class="footnote-ref"><a href="#fn-6">6</a></sup>?</p>

<p>These are the questions that should be discussed instead of simply claiming moral high-ground <em>a priori</em> and then shaming our opponents for not doing so also. The resulting lack of trust has left us ramming legislation down each other’s throats to the beat of partisan power cycles, always pushing for as much as possible so that as much as possible remains after the other side gets its shot at claw-backs.</p>

<p>Remember, Galileo, “the father of modern science”, wasn’t imprisoned for simply advocating that the earth revolves around the sun, which was counter to Catholic teaching at the time. It was because the book he wrote on the subject <a href="https://en.wikipedia.org/wiki/Galileo_affair">used slanted language that offended the Pope</a>, who quickly banned the book and put Galileo under house arrest. Only 400 years later did the Church finally admit fault. How much sooner could this have been resolved had Galileo been more tactful, even though he was right?</p>

<p>Likewise, if we drop contentious rhetoric and meme warfare from our abortion debate and adopt an atmosphere of trust via <a href="https://en.wiktionary.org/wiki/steelman">“steel man” argumentation</a>, perhaps we could soon be in a state similar to Western Europe…where people aren’t screaming at each other about abortion nearly as much.</p>

<div class="footnotes"><p id="fn-1">1. Even using the term “pro-life” (instead of “anti-abortion”) can be seen as political and triggering. We’ll get to this in detail.<a href="#fnref-1" class="footnote footnotes">↩</a></p></div>

<div class="footnotes"><p id="fn-2">2. Data Notes.  <br />

    This is a visualization and is not meant to present scientific fact. As Henry Clay said, “Statistics are no substitute for judgment”. 
    <br /> 
    <br />
    Data was sourced from ProQuest (via the New York Public Library) by doing a keyword search on US-based news articles that contained the word “abortion” at least twice, to filter out those that reference abortion only in passing (e.g. celebrity gossip). Some publications (e.g. Fox News, HuffPost) either are not in the ProQuest database or don’t provide access to full article text, so they aren’t represented in this dataset. I merged certain closely related publications under one label, e.g. New York Times and New York Times Magazine. Partisan terms were searched for using regular expressions, so "pro life" and "Pro-life", etc. are all matched. Source code is available on <a href="https://github.com/cyniphile/abortion">Github</a>.
    <br />
    <br />
    There are of course some cases where the usage of these slant terms does not reflect the author’s bias, for example when the author quotes someone else or when referenced organization names include slant terms (e.g. The National Right to Life Committee). This is a limitation of this type of analysis, but not, I think, a fatal one, as even these references still in some way present the rhetoric of the other side. 

<a href="#fnref-2" class="footnote footnotes">↩</a></p></div>

<div class="footnotes"><p id="fn-3">3. Though it is true Planned Parenthood founder Margaret Sanger supported eugenics, the vast majority of pro-choice advocates today most-likely would be strongly opposed to such ideas.<a href="#fnref-3" class="footnote footnotes">↩</a></p></div>

<div class="footnotes"><p id="fn-4">4. The pro-life camp often asserts there are a myriad of health risks that come with abortion, especially mental health risks, though there is <a href="https://www.ansirh.org/research/turnaway-study?fbclid=IwAR2o4AOwj1SuBiqdpFJNY499e1z-203KRSgWB4IwE88ApeOASbWTHNUmU6E">little-to-no evidence</a> to support this.<a href="#fnref-4" class="footnote footnotes">↩</a></p></div>

<div class="footnotes"><p id="fn-5">5. Fact check: the procedure for late-term abortion (dilation and extraction) does not actually involve cutting the women open, but it does involve puncturing the fetal head <a href="https://www.npr.org/2006/02/21/5168163/partial-birth-abortion-separating-fact-from-spin">“using scissors or another sharp instrument”</a>. <a href="#fnref-5" class="footnote footnotes">↩</a></p></div>

<div class="footnotes"><p id="fn-6">6. In fact, "Some prominent theologians, such as John Chrysostom and Thomas Sanchez, believed that post-quickening<a href="https://en.wikipedia.org/wiki/Catholic_Church_and_abortion#Early_writings"> [late term] abortion was <bold>less</bold> sinful</a> than deliberate contraception."<a href="#fnref-6" class="footnote footnotes">↩</a></p></div>]]></content><author><name></name></author><category term="abortion" /><category term="politics" /><summary type="html"><![CDATA[The vitriolic Abortion War is founded on a lack of communication that’s only getting worse. Partisan rhetoric dominates our news media (see the interactive chart below) and conversations. What can we do to move forward?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.lukeschiefelbein.com/blog/images/Abortion_Hurts_Women_(32676869635).jpg" /><media:content medium="image" url="https://www.lukeschiefelbein.com/blog/images/Abortion_Hurts_Women_(32676869635).jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>