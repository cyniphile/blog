<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Five Levels Of (Bioinformatics) Programming | Luke / blog</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Five Levels Of (Bioinformatics) Programming" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Applying five levels of supercharging to some bioinformatics code using Rust." />
<meta property="og:description" content="Applying five levels of supercharging to some bioinformatics code using Rust." />
<link rel="canonical" href="https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html" />
<meta property="og:url" content="https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html" />
<meta property="og:site_name" content="Luke / blog" />
<meta property="og:image" content="https://www.lukeschiefelbein.com/blog/images/biology-rust/2021-11-12-09-45-14.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-01T00:00:00-06:00" />
<script type="application/ld+json">
{"dateModified":"2021-12-01T00:00:00-06:00","datePublished":"2021-12-01T00:00:00-06:00","description":"Applying five levels of supercharging to some bioinformatics code using Rust.","image":"https://www.lukeschiefelbein.com/blog/images/biology-rust/2021-11-12-09-45-14.png","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html"},"url":"https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html","headline":"Five Levels Of (Bioinformatics) Programming","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css">
  <script src="/blog/assets/js/iframeResizer.min.js"></script><link type="application/atom+xml" rel="alternate" href="https://www.lukeschiefelbein.com/blog/feed.xml" title="Luke / blog" /><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-52542530-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-52542530-2');
</script>



<link rel="shortcut icon" type="image/x-icon" href="/blog/images/favicon.ico">
<link rel="apple-touch-icon" sizes="152x152" href="/blog/images/favicon_package_v0.16/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon_package_v0.16/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon_package_v0.16/favicon-16x16.png">
<link rel="manifest" href="/blog/images/favicon_package_v0.16/site.webmanifest">
<link rel="mask-icon" href="/blog/images/favicon_package_v0.16/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" rel="stylesheet">


<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Five Levels Of (Bioinformatics) Programming | Luke / blog</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Five Levels Of (Bioinformatics) Programming" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Applying five levels of supercharging to some bioinformatics code using Rust." />
<meta property="og:description" content="Applying five levels of supercharging to some bioinformatics code using Rust." />
<link rel="canonical" href="https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html" />
<meta property="og:url" content="https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html" />
<meta property="og:site_name" content="Luke / blog" />
<meta property="og:image" content="https://www.lukeschiefelbein.com/blog/images/biology-rust/2021-11-12-09-45-14.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-01T00:00:00-06:00" />
<script type="application/ld+json">
{"dateModified":"2021-12-01T00:00:00-06:00","datePublished":"2021-12-01T00:00:00-06:00","description":"Applying five levels of supercharging to some bioinformatics code using Rust.","image":"https://www.lukeschiefelbein.com/blog/images/biology-rust/2021-11-12-09-45-14.png","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html"},"url":"https://www.lukeschiefelbein.com/blog/programming/rust/biology/2021/12/01/biology-rust.html","headline":"Five Levels Of (Bioinformatics) Programming","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://www.lukeschiefelbein.com/blog/feed.xml" title="Luke / blog" /><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-52542530-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-52542530-2');
</script>




    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">
  <div class="wrapper"><div>
      <a class="site-title" href="https://www.lukeschiefelbein.com">Luke</a>
      <div style='color: #C33D3D' class="slash">/</div>
      <div style='color: #CCD537' class="slash">/</div>
      <div style='color: #3EBEC3' class="slash">/</div>
      <a class="site-title" rel="author" href="/blog/">blog</a>
    </div>
  </div>
  <hr>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Five Levels Of (Bioinformatics) Programming</h1><p class="page-description">Applying five levels of supercharging to some bioinformatics code using Rust.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-12-01T00:00:00-06:00" itemprop="datePublished">
        Dec 1, 2021
      </time>
       ‚Ä¢ <span class="read-time" title="Estimated read time">
    
    
      21 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#programming">programming</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#rust">rust</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#biology">biology</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          
          
          
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#level-1-python">Level 1: Python</a></li>
<li class="toc-entry toc-h1"><a href="#level-2-rust">Level 2: Rust</a>
<ul>
<li class="toc-entry toc-h3"><a href="#if-you-already-know-what-rust-is-skip-this">If You Already Know What Rust Is, Skip This</a></li>
<li class="toc-entry toc-h2"><a href="#rust-transcribe">Rust .transcribe</a></li>
<li class="toc-entry toc-h2"><a href="#more-thorough-performance-comparisons">More Thorough Performance Comparisons</a></li>
<li class="toc-entry toc-h2"><a href="#actually-speeding-something-up">Actually Speeding Something Up</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#level-3-algebraic-data-types">Level 3: Algebraic Data Types</a>
<ul>
<li class="toc-entry toc-h2"><a href="#speed">Speed</a></li>
<li class="toc-entry toc-h2"><a href="#what-about-python">What About Python?</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#level-4-parallelize">Level 4: Parallelize</a></li>
<li class="toc-entry toc-h1"><a href="#level-5">Level 5?</a></li>
<li class="toc-entry toc-h1"><a href="#tldr">TL;DR</a></li>
<li class="toc-entry toc-h1"><a href="#notes">Notes</a></li>
</ul><h1 id="level-1-python">
<a class="anchor" href="#level-1-python" aria-hidden="true"><span class="octicon octicon-link"></span></a>Level 1: Python</h1>

<p>I want to make the switch from ‚Äúdata science‚Äù to bioinformatics. Most of my statistics and machine learning skills will transfer pretty seamlessly to this new domain, but I‚Äôve also been learning more bioinformatics by doing <a href="rosalind.info">Rosalind problems</a>. Rosalind is like <a href="https://projecteuler.net/archives">Project Euler</a> with a biology focus. I started out solving the problems in Python, the language I know best.</p>

<p>For example, in the second Rosalind <a href="http://rosalind.info/problems/rna/">problem</a> we‚Äôre asked to write a function that transcribes DNA to RNA. Here‚Äôs my Python solution:<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">1</a></sup>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># python hand-rolled
</span><span class="k">def</span> <span class="nf">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">"U"</span> <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">'T'</span> <span class="k">else</span> <span class="n">char</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">])</span>
</code></pre></div></div>
<hr>

<h1 id="level-2-rust">
<a class="anchor" href="#level-2-rust" aria-hidden="true"><span class="octicon octicon-link"></span></a>Level 2: Rust</h1>

<p>I realized this would be a perfect opportunity to try out <a href="https://www.rust-lang.org/">Rust</a>, which is supposed to make writing extremely fast code safer and easier.</p>

<h3 id="if-you-already-know-what-rust-is-skip-this">
<a class="anchor" href="#if-you-already-know-what-rust-is-skip-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>If You Already Know What Rust Is, Skip This</h3>

<p>Rust is a ‚Äúlow-level language with high-level abstractions.‚Äù It‚Äôs supposed to be as fast and as fine-grained as C, but more ‚Äúergonomic‚Äù (less code to write because of the said high-level abstractions) and also much safer from bugs.</p>

<p>Rust is fast partially because it‚Äôs not garbage collected. Instead, the compiler helps you manually manage memory. To this end it requires you, the programmer, to write some extra bookkeeping annotations that say which functions are using which variables and when (so-called ‚Äúownership‚Äù with ‚Äúborrowing‚Äù and ‚Äúlifetimes‚Äù). I‚Äôve seen this called ‚Äúsemiautomatic memory management‚Äù (as opposed to C/C++ which are fully manual; the compiler doesn‚Äôt stop you from making mistakes). This is why people often complain about ‚Äúfighting the compiler‚Äù with Rust: it‚Äôs always pointing out inconsistencies in your variable management (in addition to all the usual type errors you get from more typical compilers). That said, once something does compile, you should have a memory-safe, robust, and probably very fast program.</p>

<p>There are also other low-level complexities of the language. For example, there is not one <code class="highlighter-rouge">int</code> type but <em>eight</em>, depending on if you want the integer to be signed and how many bits you want to represent it with. You have to understand the basics of stack versus heap memory. Strings are <a href="https://fasterthanli.me/articles/working-with-strings-in-rust">very complicated</a>. And so on.</p>

<p>The <a href="https://doc.rust-lang.org/book/">Rust book</a> is a great resource for learning the language. Rust has a steep learning curve, but I‚Äôve also not really done low-level programming before, so a lot of the effort for me was learning <em>that</em>. Overall I‚Äôve found Rust is like bowling with the bumpers: it can be maddening to be always bouncing back and forth down the lane, but eventually I always knock some pins over, as opposed to C++ where I‚Äôd probably never trust my code to run in a production environment, especially one as correctness-critical as biology.</p>

<h2 id="rust-transcribe">
<a class="anchor" href="#rust-transcribe" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rust <code class="highlighter-rouge">.transcribe</code>
</h2>

<p>The Rust implementation of <code class="highlighter-rouge">.transcribe</code> is pretty similar to the Python one (especially since I used Python type hints), except for the <code class="highlighter-rouge">&amp;</code> borrow notation and the <code class="highlighter-rouge">.collect</code> one has to explicitly call on the lazily evaluated <code class="highlighter-rouge">.chars</code> iterator.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// rust hand-rolled</span>
<span class="nd">#[pyfunction]</span>
<span class="k">fn</span> <span class="nf">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">dna</span>
        <span class="nf">.chars</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="sc">'T'</span> <span class="p">{</span> <span class="sc">'U'</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">x</span> <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Additionally, I added the decorator-looking <code class="highlighter-rouge">#[pyfunction]</code> thing (actually a Rust macro) from the <a href="https://github.com/PyO3/pyo3">PyO3 Rust package</a> which makes it really easy to use Rust with Python<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">2</a></sup>.  You (more or less) just add such a prefix, and then you can call the Rust function from Python like so:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># calling rust functions from python
</span><span class="kn">import</span> <span class="nn">bio_lib_string_rs</span>

<span class="n">dna</span> <span class="o">=</span> <span class="s">"ACTGACTC"</span>
<span class="n">bio_lib_string_rs</span><span class="o">.</span><span class="n">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">)</span>
</code></pre></div></div>
<p>Since the Rust version is callable from Python, I easily wrapped both implementations in <a href="https://github.com/cyniphile/rosalind/blob/main/tests/test_benchmark.py">pytest benchmarks</a>. For the initial test I used a small DNA file of ~1000bp and got the following result:
<img src="/blog/images/biology-rust/2021-11-09-17-54-55.png" alt=""></p>

<p>Woot. The Rust version is nearly 20x faster<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">3</a></sup>, including the overhead of parsing the Python DNA string into a Rust string. I also ran a <a href="https://github.com/cyniphile/rosalind/blob/04885c9644e1cff2287a43dce94763e80f482c39/bio-lib-string-rs/src/lib.rs#L195">pure Rust benchmark on the same data</a> (no Python involved) and Rust was over 50x faster than Python.</p>

<h2 id="more-thorough-performance-comparisons">
<a class="anchor" href="#more-thorough-performance-comparisons" aria-hidden="true"><span class="octicon octicon-link"></span></a>More Thorough Performance Comparisons</h2>

<p>Now some of you Pythonistas might be foaming at the mouth and swearing at your screen right now because the way I implemented <code class="highlighter-rouge">transcribe</code> wasn‚Äôt very Pythonic. I hand-rolled the following function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># python hand-rolled 
</span><span class="k">def</span> <span class="nf">transcribe</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">"U"</span> <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s">'T'</span> <span class="k">else</span> <span class="n">char</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">dna</span><span class="p">])</span>
</code></pre></div></div>

<p>when I could have just used Python‚Äôs built-in <code class="highlighter-rouge">.replace</code> function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># python built-in
</span><span class="k">def</span> <span class="nf">transcribe_builtin</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">dna</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">"T"</span><span class="p">,</span> <span class="s">"U"</span><span class="p">)</span>
</code></pre></div></div>

<p>Sure, Rust is a lot faster if we compare apples-to-apples implementations of the same algorithm, but that‚Äôs not quite fair in this case because you‚Äôd never actually use the hand-rolled implementation in Python, or even Rust for that matter (which also has a built-in <code class="highlighter-rouge">.replace</code>). So I <a href="https://github.com/cyniphile/rosalind/blob/main/tests/test_benchmark.py">benchmarked the built-ins</a> as well:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// rust built-in</span>
<span class="nd">#[pyfunction]</span>
<span class="k">fn</span> <span class="nf">transcribe_builtin</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">dna</span><span class="nf">.replace</span><span class="p">(</span><span class="s">"T"</span><span class="p">,</span> <span class="s">"U"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And also the Python <code class="highlighter-rouge">numpy</code> package built-in:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># numpy 
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">transcribe_np</span><span class="p">(</span><span class="n">dna</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">dna</span><span class="p">,</span> <span class="s">"T"</span><span class="p">,</span> <span class="s">"U"</span><span class="p">))</span>  <span class="c1"># type: ignore
</span></code></pre></div></div>
<p>I also set up some <a href="https://github.com/cyniphile/rosalind/blob/f8f0c3b89a34f269cdbce05e74fed93c198ace35/bio-lib-string-rs/src/lib.rs#L213">separate benchmarks</a> of the Rust functions called directly in Rust, no Python or PyO3 involved. Here are the results on the 1kbp file:</p>

<p><img src="/blog/images/biology-rust/2021-11-09-18-22-16.png" alt=""></p>

<p>The Python built-in <code class="highlighter-rouge">.replace</code> function is actually the fastest by far. It‚Äôs over twice as fast as my Rust function and the Rust <code class="highlighter-rouge">.replace</code> built-in.</p>

<p>This sort of makes sense since Python‚Äôs <code class="highlighter-rouge">.replace</code> is actually just <a href="https://github.com/python/cpython/blob/5f9247e36a0213b0dcfd43533db5cf6570895cfd/Objects/stringlib/transmogrify.h#L678">a highly optimized C function</a>, though it‚Äôs still surprising that the Rust <code class="highlighter-rouge">.replace</code> built-in is a lot slower<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">4</a></sup>.</p>

<p>The same ranking holds true over different sizes of data, though numpy seems to eventually overcome some fixed initialization overhead.</p>

<p><img src="/blog/images/biology-rust/2021-11-09-17-27-36.png" alt="">
This plot was made using a <a href="https://github.com/nschloe/perfplot"><code class="highlighter-rouge">perfplot</code></a>-based Python script, so the pure Rust functions weren‚Äôt included.</p>

<h2 id="actually-speeding-something-up">
<a class="anchor" href="#actually-speeding-something-up" aria-hidden="true"><span class="octicon octicon-link"></span></a>Actually Speeding Something Up</h2>

<p>I decided to try out a more domain-specific bioinformatics task that isn‚Äôt already a Python built-in. This next Rosalind problem is to <a href="http://rosalind.info/problems/revp/">identify reverse palindromes</a> in a DNA sequence, Python answer below<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">5</a></sup>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">PalindromeLocation</span><span class="p">:</span>
    <span class="n">start_index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">int</span>


<span class="k">def</span> <span class="nf">find_reverse_palindromes</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
    <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">test_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>
                <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">PalindromeLocation</span><span class="p">(</span><span class="n">start_index</span><span class="o">=</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">locations</span>


<span class="k">def</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">reverse_complement_dna</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">reverse_complement_dna</span><span class="p">(</span><span class="n">dna_seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">dna_base_complement</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">dna_seq</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>


<span class="k">def</span> <span class="nf">dna_base_complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> 
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"A"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"T"</span>
    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"T"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"A"</span>
    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"G"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"C"</span>
    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s">"C"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"G"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">"Non-DNA base </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> found."</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
</code></pre></div></div>

<p>The Rust implementation is very similar but uses a slightly more functional style (<code class="highlighter-rouge">.fold</code> instead of an outer <code class="highlighter-rouge">for</code> loop)<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[pyclass]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PalindromeLocation</span> <span class="p">{</span>
    <span class="nd">#[pyo3(get,</span> <span class="nd">set)]</span>
    <span class="k">pub</span> <span class="n">start_index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="nd">#[pyo3(get,</span> <span class="nd">set)]</span>
    <span class="k">pub</span> <span class="n">length</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[pyfunction]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_reverse_palindromes</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">seq</span><span class="nf">.chars</span><span class="p">()</span>
        <span class="nf">.take</span><span class="p">(</span><span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">_</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">length</span> <span class="nf">in</span> <span class="p">(</span><span class="n">min_len</span><span class="o">..</span><span class="p">(</span><span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">test_seq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)];</span>
                <span class="k">if</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">PalindromeLocation</span> <span class="p">{</span>
                        <span class="n">start_index</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">length</span><span class="p">,</span>
                    <span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">acc</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">seq</span> <span class="o">==</span> <span class="nf">reverse_complement_dna</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">reverse_complement_dna</span><span class="p">(</span><span class="n">dna_seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="n">dna_seq</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">dna_base_complement</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">dna_base_complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">base</span> <span class="p">{</span>
        <span class="sc">'A'</span> <span class="k">=&gt;</span> <span class="sc">'T'</span><span class="p">,</span>
        <span class="sc">'T'</span> <span class="k">=&gt;</span> <span class="sc">'A'</span><span class="p">,</span>
        <span class="sc">'G'</span> <span class="k">=&gt;</span> <span class="sc">'C'</span><span class="p">,</span>
        <span class="sc">'C'</span> <span class="k">=&gt;</span> <span class="sc">'G'</span><span class="p">,</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Non-DNA base </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> found."</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And I also added a small Python wrapper to map the Rust <code class="highlighter-rouge">PalindromeLocation</code> <code class="highlighter-rouge">struct</code> to the Python <code class="highlighter-rouge">dataclass</code>, which adds some more language interface overhead<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_reverse_palindromes_rs</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">bio_lib_string_rs</span><span class="o">.</span><span class="n">find_reverse_palindromes</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span> 
        <span class="n">PalindromeLocation</span><span class="p">(</span>
            <span class="n">start_index</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">start_index</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">length</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span> 
    <span class="p">]</span>
</code></pre></div></div>

<p>I also made a Python implementation that uses Numpy arrays <a href="https://github.com/cyniphile/rosalind/blob/04885c9644e1cff2287a43dce94763e80f482c39/bio-lib-py/bio_lib_py/bio_lib.py#L82">(see the repo for details)</a>.</p>

<p>How did things pan out this time?</p>

<p><img src="/blog/images/biology-rust/output.png" alt=""></p>

<p>Rust is about 15x faster than base Python, even with all the conversion overhead! Was it worth the effort? I‚Äôd say ‚Äúyes!‚Äù Writing these relatively simple Rust functions is frankly pretty easy (though Rust definitely can get a lot harder). The PyO3 crate makes it pretty straightforward to incrementally add the extra ‚ÄúRust thrust‚Äù (new viral hashtag?) when you need it. This wasn‚Äôt without paper-cuts or head-scratchers, but if this was for heavily reused code (perhaps part of some data pipeline), it‚Äôs well worth the price of implementation.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">8</a></sup></p>

<hr>

<h1 id="level-3-algebraic-data-types">
<a class="anchor" href="#level-3-algebraic-data-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Level 3: Algebraic Data Types</h1>

<p>So far I‚Äôve just represented DNA as strings. This is bad, and here‚Äôs an example of why.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">dna_base_complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">base</span> <span class="p">{</span>
        <span class="sc">'A'</span> <span class="k">=&gt;</span> <span class="sc">'T'</span><span class="p">,</span>
        <span class="sc">'T'</span> <span class="k">=&gt;</span> <span class="sc">'A'</span><span class="p">,</span>
        <span class="sc">'G'</span> <span class="k">=&gt;</span> <span class="sc">'C'</span><span class="p">,</span>
        <span class="sc">'C'</span> <span class="k">=&gt;</span> <span class="sc">'G'</span><span class="p">,</span>
        <span class="c">// Commented out for now...</span>
        <span class="c">// _ =&gt; panic!("Non-DNA base \"{}\" found.", base),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This Rust little function, when given a DNA base, returns the complementary base. Note I had to name it <code class="highlighter-rouge">dna_base_complement</code>, because it only works with DNA. If you understand basic biology, you know the output is also DNA (not RNA, or amino acids). However, none of this information is encoded in the logic of the function‚Äôs code.</p>

<p>I‚Äôve commented out a line in the code above, and without it, the function actually doesn‚Äôt compile. Rust checks pattern matches for exhaustivity, and since <em>any</em> UTF-8 <code class="highlighter-rouge">char</code> can be passed in to this function, I have to also handle the case where the <code class="highlighter-rouge">base</code> argument happens to not be ‚ÄúA‚Äù, ‚ÄúC‚Äù, ‚ÄúT‚Äù, or ‚ÄúG‚Äù.</p>

<p><img src="/blog/images/biology-rust/2021-11-12-08-45-01.png" alt=""></p>

<p>So I have to uncomment that last line, which is a catch-all case. Now if I somehow give a non-DNA character to our function at runtime, the program will panic (and crash if the panic isn‚Äôt handled). Say I accidentally pass in the RNA character ‚ÄúU‚Äù‚Ä¶uh oh!</p>

<p>Using Rust‚Äôs type system I can completely eliminate the possibility of this kind of error. Specifically, I made use of <em>Algebraic Data Types</em> or ADTs.</p>

<p>Algebraic data types are simply types composed of other types. There are two main kinds of ADTs: product types and sum types. A product type is an AND group of types: for example tuples, <code class="highlighter-rouge">struct</code>s, or Python <code class="highlighter-rouge">dataclass</code>es. These are pretty obviously useful: sometimes you need to group diversely typed data together under one type, like a <code class="highlighter-rouge">user</code> type that has  string <code class="highlighter-rouge">name</code> AND integer <code class="highlighter-rouge">age</code> fields.</p>

<p>The other common ADT, the sum type, was new to me, but I‚Äôve realized it‚Äôs perhaps even more powerful and interesting<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>. A sum type is an XOR group of different types, so an instance can be one (and only one) type out of a set of given options. In Rust you create sum types with the <code class="highlighter-rouge">enum</code> keyword. For example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">DnaNucleotide</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">C</span><span class="p">,</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This defines <code class="highlighter-rouge">DnaNucleotide</code> as a new type that can be one of four variants<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup> <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">C</code>, <code class="highlighter-rouge">G</code>, or <code class="highlighter-rouge">T</code>. Why is this interesting? Well, now I can rewrite my <code class="highlighter-rouge">complement</code> function like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">complement</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="n">DnaNucleotide</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">DnaNucleotide</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">base</span> <span class="p">{</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">T</span><span class="p">,</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">T</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">A</span><span class="p">,</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">C</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">G</span><span class="p">,</span>
          <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">G</span> <span class="k">=&gt;</span> <span class="nn">DnaNucleotide</span><span class="p">::</span><span class="n">C</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note I dropped the <code class="highlighter-rouge">dna_</code> prefix from the function name: I know I‚Äôm getting the complement of DNA because the <code class="highlighter-rouge">base</code> argument is of <code class="highlighter-rouge">DnaNucleotide</code> type, and so is the return type. It only accepts DNA, not RNA or ‚Äú!‚Äù or ‚Äú‰∏∫‚Äù or ‚ÄúüåØ‚Äù. And if I try to pass in a character I get a <em>compile time</em> error:</p>

<p><img src="/blog/images/biology-rust/2021-11-12-09-45-14.png" alt=""></p>

<p>We aren‚Äôt even allowed to wire <code class="highlighter-rouge">complement</code> up to anything but its proper DNA input. We also get another neat exhaustivity check at compile time if I forget to handle one of the enumerated bases:</p>

<p><img src="/blog/images/biology-rust/2021-11-12-09-40-15.png" alt=""></p>

<p>This time I don‚Äôt have to add the catch-all <code class="highlighter-rouge">_ =&gt; panic!("Non-DNA base \"{}\" found.", base)</code> case because the compiler knows there can only be 4 different <code class="highlighter-rouge">DnaNucleotide</code> variants, and I‚Äôve properly handled all of them. While this example might seem trivial, what about, say, a function from codons to amino acids? If I forget or duplicate one of the $4^3$ codons (like I did below), the compiler tells us!</p>

<p><img src="/blog/images/biology-rust/2021-11-12-09-49-10.png" alt="">
Note in this example I‚Äôve made use of <code class="highlighter-rouge">RnaNucleotide</code> and <code class="highlighter-rouge">AminoAcid</code> enums that I defined <a href="https://github.com/cyniphile/rosalind/blob/main/bio-lib-algebraic-rs/src/lib.rs">elsewhere in the code</a>.</p>

<p>This is also useful for easily adapting the software to work with <a href="https://en.wikipedia.org/wiki/Alloprotein#:~:text=An%20alloprotein%20is%20a%20novel,non%2Dnatural%22%20amino%20acids.&amp;text=The%20usual%20mechanisms%2C%20which%20produce,novel%20proteins%20the%20same%20way.">alloproteins</a> (proteins with non-natural amino acids) or <a href="https://en.wikipedia.org/wiki/D5SICS">artificial base pairs</a>. All I‚Äôd have to do is add another symbol to the ‚ÄúAminoAcid‚Äù or ‚ÄúDnaNucleotide‚Äù enums, and then a bunch of exhaustivity checking compiler errors will pop up wherever I now need to handle the new variant types.</p>

<h2 id="speed">
<a class="anchor" href="#speed" aria-hidden="true"><span class="octicon octicon-link"></span></a>Speed</h2>

<p>Does all this organizational overhead make our code perform less efficiently? Well, theoretically it could actually make it more efficient. Strings (in both Rust and Python) are encoded in UTF-8 which uses a minimum of 8-bits per symbol. DNA has only four symbols and so only really needs 2 bits. Another consideration is parsing: if our DNA is saved in a file (say <a href="https://en.wikipedia.org/wiki/FASTA_format">FASTA format</a> which just uses character strings), we have to read the file <em>and</em> parse it into our internal enum representation. This means <a href="https://github.com/cyniphile/rosalind/blob/99c3fdb60985b09e9418b308d9bdae4a7657ecbe/bio-lib-algebraic-rs/src/lib.rs#L86">more code to write</a> and more computational overhead.</p>

<p>I wasn‚Äôt sure how the trade-off would play out, so I just benchmarked everything using the excellent <a href="https://github.com/bheisler/criterion.rs"><code class="highlighter-rouge">criterion</code></a> package for Rust. I compared the original string <code class="highlighter-rouge">find_reverse_palindromes</code> function with one that operates on a vector of <code class="highlighter-rouge">DnaNucleotide</code> enums. I also timed the ADT/enum version both including the string-to-enum parsing step, and a pre-parsed version where I only timed the palindrome searching part. Drumroll‚Ä¶</p>

<p><img src="/blog/images/biology-rust/Schermata-2021-11-16-alle-15.51.28.png" alt=""></p>

<p>It looks like Rust‚Äôs promise of ‚Äúzero-cost abstractions‚Äù is is a lie, we are actually getting <em>negative</em> cost abstractions here! Even including the parsing overhead, the ADT-based version of our function is over twice as fast as the string version. The Rust compiler clearly takes advantage of the <code class="highlighter-rouge">enum</code> representation to make some key optimizations (though I couldn‚Äôt tell what these optimizations actually are when comparing the <a href="https://github.com/cyniphile/rosalind/blob/main/bio-lib-algebraic-rs/asm_output/find_reverse_palindromes_adt.asm">emitted assembly and LLVM IR</a> of the two functions. I leave that as an exercise for the reader üòÉ).</p>

<h2 id="what-about-python">
<a class="anchor" href="#what-about-python" aria-hidden="true"><span class="octicon octicon-link"></span></a>What About Python?</h2>

<p>ADTs sort-of <a href="https://stackoverflow.com/questions/16258553/how-can-i-define-algebraic-data-types-in-python">exist in Python</a> while using <code class="highlighter-rouge">mypy</code> typechecking, which even offers hacky-feeling <a href="https://hakibenita.com/python-mypy-exhaustive-checking">exhaustivity checks</a>. However, Enum support is <a href="https://github.com/PyO3/pyo3/issues/834">not quite ready in PyO3</a>, so it‚Äôs not yet possible to call enum-based Rust functions from Python. To use Rust in Python, we‚Äôll just have to wrap our ADT-style function with one that accepts a string and pre-parses it into a vector of enums:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[pyfunction]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_reverse_palindrome_dna</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">seq</span> <span class="o">=</span> <span class="nn">DNA</span><span class="p">::</span><span class="nf">parse_string</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
    <span class="nf">find_reverse_palindromes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>While this hack unfortunately sequesters all the nice ADT-related type checks to the Rust side of the code, at least it allows us to take advantage of the speed boost of using enums in Python.</p>

<hr>

<h1 id="level-4-parallelize">
<a class="anchor" href="#level-4-parallelize" aria-hidden="true"><span class="octicon octicon-link"></span></a>Level 4: Parallelize</h1>

<p>So far I‚Äôve been ignoring one of the most important speed factors in modern programming: parallelism. It‚Äôs always slightly painful to see my six-core Intel i7 running at, well, 1/6 capacity!</p>

<p>I decided to try out the newish <a href="https://github.com/ray-project/ray">ray</a> package to parallelize my Python code. I ran into some gotchas, but the <a href="https://docs.ray.io/en/latest/ray-design-patterns/fine-grained-tasks.html">tutorials</a> were generally helpful. The code for finding reverse palindromes ended up being reasonably similar to the single-threaded version , though it requires an extra parameter <code class="highlighter-rouge">BATCH_SIZE</code> which needs be tuned to optimally slice up work into chunks:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ray</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>


<span class="k">def</span> <span class="nf">find_reverse_palindromes_par</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
    <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ray_seq</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>  <span class="c1"># type: ignore
</span>    <span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="o">@</span><span class="n">ray</span><span class="o">.</span><span class="n">remote</span>  <span class="c1"># type: ignore
</span>    <span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PalindromeLocation</span><span class="p">]:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ray_seq</span><span class="p">)</span>  <span class="c1"># type: ignore
</span>        <span class="n">locations_inner</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">BATCH_SIZE</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c1"># type: ignore
</span>                    <span class="k">continue</span>
                <span class="n">test_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)]</span>  <span class="c1"># type: ignore
</span>                <span class="k">if</span> <span class="n">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">):</span>  <span class="c1"># type: ignore
</span>                    <span class="n">locations_inner</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">PalindromeLocation</span><span class="p">(</span><span class="n">start_index</span><span class="o">=</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">locations_inner</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BATCH_SIZE</span><span class="p">):</span>
        <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">is_palindrome</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="nb">reduce</span><span class="p">(</span> <span class="c1"># flatten list of list
</span>        <span class="n">operator</span><span class="o">.</span><span class="n">iconcat</span><span class="p">,</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">locations</span><span class="p">),</span> <span class="p">[]</span>  <span class="c1"># type: ignore
</span>    <span class="p">)</span>
</code></pre></div></div>
<p>Now let‚Äôs run this and take a look at our CPU monitor:</p>

<p><img src="/blog/images/biology-rust/2021-11-24-16-46-34.png" alt="">
Yeah baby! All six cores fully engaged sir!</p>

<p>Parallelizing the Rust code turned out to be the first case where implementation is actually easier in Rust than Python thanks to the excellent <a href="https://github.com/rayon-rs/rayon"><code class="highlighter-rouge">rayon</code></a> package:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_reverse_palindromes_par</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">DNASlice</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">min_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">seq</span><span class="nf">.into_par_iter</span><span class="p">()</span>
        <span class="nf">.take</span><span class="p">(</span><span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">,</span> <span class="p">|</span><span class="k">mut</span> <span class="n">acc</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">_</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">length</span> <span class="nf">in</span> <span class="p">(</span><span class="n">min_len</span><span class="o">..</span><span class="p">(</span><span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">test_seq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">)];</span>
                <span class="k">if</span> <span class="nf">is_reverse_palindrome</span><span class="p">(</span><span class="n">test_seq</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">PalindromeLocation</span> <span class="p">{</span>
                        <span class="n">start_index</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="n">length</span><span class="p">,</span>
                    <span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">acc</span>
        <span class="p">})</span>
        <span class="nf">.reduce</span><span class="p">(</span>
            <span class="nn">Vec</span><span class="p">::</span><span class="n">new</span><span class="p">,</span>
            <span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PalindromeLocation</span><span class="o">&gt;</span><span class="p">|</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span><span class="nf">.concat</span><span class="p">(),</span>
        <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It‚Äôs as simple as changing <code class="highlighter-rouge">.iter</code> to <code class="highlighter-rouge">.into_par_iter</code> and adding a <code class="highlighter-rouge">reduce</code> function at the end to stitch together all the asynchronously returned results. Of course, it also needed to be wrapped in similar Python-&gt;string-&gt;enum/ADT wrapper functions to be useable from Python.</p>

<p>So now it‚Äôs time for the final showdown. How do all these ‚Äúlevels‚Äù compare speed-wise?</p>

<p><img src="/blog/images/biology-rust/2021-11-23-22-01-06.png" alt="">
Remember these results are all calls from Python.</p>

<p>While both parallel implementations are slower for smaller inputs (as expected), the Python version is <em>much</em> slower, and it eventually returns to being slower than sequential Python. This was because the <code class="highlighter-rouge">BATCH_SIZE</code> parameter needed some tuning, and after some tedious brute force experimentation, I ended up finding a slightly better value (that was still slower than single-threaded Rust). However Rust‚Äôs <code class="highlighter-rouge">rayon</code> performed excellently out of the box thanks to it‚Äôs built-in dynamic performance tuning.</p>

<p>It‚Äôs neat to see the performance gains for each of our ‚Äúlevels‚Äù of code improvement. In the end, I made my code safer, better organized, <em>and</em> faster by nearly two orders of magnitude. The overhead of learning Rust is certainly high, but hey, I‚Äôm already over that hump!</p>

<hr>

<h1 id="level-5">
<a class="anchor" href="#level-5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Level 5?</h1>

<p>To avoid publication bias, I admit I also tried a ‚ÄúLevel 5‚Äù improvement by using iterators more heavily. But, well, gather round‚Ä¶</p>

<p>I was discussing this project with a hacker friend who suggested modifying my functions to return iterators instead of vectors. This way, I could chain together various transformation functions lazily and only call <code class="highlighter-rouge">.collect</code> when needed. The compiler could than optimize the entire chain of transformations top to bottom instead of being forced to return a vector at each step. Since I‚Äôm a data scientist with a Spark background, this suggestion made a lot of sense.</p>

<p>This is where implementing things in Rust got incredibly tricky, and frankly very unproductive. I had to switch over to Rust‚Äôs nightly build to be able to make use of experimental typing features. I had to rewrite one line functions as 25-line home-made iterator implementations. I had to really get in the mud with lifetimes, traits, and generics, leading to function signatures like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">transcribe</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">DnaIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">RnaNucleotide</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span>
<span class="k">where</span>
    <span class="n">DnaIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="n">seq</span><span class="nf">.map</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="nf">transcribe_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the end, my code was much <em>less</em> clean, though I could have possibly made it cleaner by using performance-sapping dynamic dispatch<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup>.</p>

<p>I should have stopped and benchmarked sooner, but instead I struggled to port the entire set of bioinformatics functions I‚Äôd written so far to this iterators based implementation. <a href="https://github.com/cyniphile/rosalind/blob/main/bio-lib-rs/src/lib.rs">The entire monstrosity is available here</a>. And yes, in the end, the code was significantly (~10%) slower. See one benchmark below:</p>

<p><img src="/blog/images/biology-rust/2021-11-24-16-12-39.png" alt=""></p>

<p>It would have needed to be a lot faster to justify all the extra work and codebase messiness. Given it was pretty hard to find examples of people using this iterator pattern online, I‚Äôm guessing it‚Äôs pretty much an anti-pattern. The Rust compiler is clearly worse at optimizing code written this way. In the Rust community, there‚Äôs a lot of talk about ‚Äúidiomatic‚Äù code, and I see the value. Unless you‚Äôre fluent in assembly and compilers (I‚Äôm not), just writing Rust idiomatically seems like an important heuristic for also getting performant Rust. In this case, I violated a universal idiom of all programming languages: ‚Äúif you‚Äôre writing lots of complicated code to do simple things, you‚Äôre probably doing it wrong.‚Äù</p>

<p>I guess 4 levels of improvement was enough‚Ä¶</p>

<h1 id="tldr">
<a class="anchor" href="#tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>TL;DR</h1>

<ul>
  <li>Rust is faster than Python, but not necessarily for very simple things.</li>
  <li>It‚Äôs pretty easy and efficient to call fast Rust functions from Python.</li>
  <li>Use algebraic data types, especially sum types. ADT-based code is cleaner, safer, and faster.</li>
  <li>Parallelization is important, and it‚Äôs easy(er) to do in Rust.</li>
  <li>Benchmark, don‚Äôt theorize. <a href="https://github.com/flamegraph-rs/flamegraph#humans-are-terrible-at-guessing-about-performance">‚ÄúHumans are terrible at guessing about performance!‚Äù</a>
</li>
  <li>Writing Rust simply and idiomatically will probably make the fastest code (as well as the cleanest).</li>
</ul>

<h1 id="notes">
<a class="anchor" href="#notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notes</h1>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:3" role="doc-endnote">
      <p>DNA sequence data are stored as the coding strand (not the template strand), so ‚Äútranscription‚Äù really does mean ‚Äúreplace T with U‚Äù not ‚Äúfind the RNA complement strand‚Äù¬†<a href="#fnref:3" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>For a more detailed tutorial <a href="https://depth-first.com/articles/2020/08/10/python-extensions-in-pure-rust-with-pyo3/">see this guide</a>. Installing and using PyO3 had some paper-cuts:</p>
      <ul>
        <li>I needed to add <a href="https://stackoverflow.com/questions/28124221/error-linking-with-cc-failed-exit-code-1">a mysterious config</a> to get it to compile on Mac:</li>
        <li>The VSCode <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">rust-analyzer</a> has a bug where it <a href="https://github.com/rust-analyzer/rust-analyzer/issues/6716">shows</a> fake <a href="https://stackoverflow.com/questions/65223576/what-does-the-rust-analyzer-error-could-not-resolve-macro-crateformat-args">errors</a> in PyO3 macros.</li>
        <li>With PyO3 installed, my project began to show some of Rust‚Äôs infamous slow compile times (it went from a couple of seconds ~22s).</li>
      </ul>
      <p><a href="#fnref:7" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>It‚Äôs important to use the super-optimized (and slow compiling) <code class="highlighter-rouge">--release</code> flag here. Otherwise, Rust compiles using the default fast-compiling/slow-performing <code class="highlighter-rouge">--debug</code> setting. Check out the performance difference for the <code class="highlighter-rouge">transcribe</code> function: <img src="/blog/images/biology-rust/2021-11-09-12-46-33.png" alt="">¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Perhaps this is because CPython is compiled with gcc, <a href="https://news.ycombinator.com/item?id=20944403">which can sometimes emit faster instructions than Rust‚Äôs LLVM-based compiler</a>. Or perhaps something else; I didn‚Äôt look into it too closely.¬†<a href="#fnref:2" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Yes, I know, this is not the best algorithm. That‚Äôs not the point. The point is to compare the same algorithm in Rust and Python. Side note: I wanted to try out Python 3.10‚Äôs new <a href="https://www.python.org/dev/peps/pep-0636/">pattern matching</a>, but I couldn‚Äôt install some dependencies (SciPy), so I had to go back to version 3.9.¬†<a href="#fnref:6" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>This was the first time I ran into not-so-nice problems with PyO3. I started with a Rust implementation <a href="https://github.com/cyniphile/rosalind/blob/04885c9644e1cff2287a43dce94763e80f482c39/bio-lib-string-rs/src/lib.rs#L139">nearly identical to the Python one</a> but I ran into a weird GIL deadlock when benchmarking with <code class="highlighter-rouge">perfplot</code> (which apparently does some multithreaded stuff). I managed to resolve this by not having any <code class="highlighter-rouge">mut</code> or borrowed variables in the function body, but this was a quick hack fix. I have not yet gone deep on the <a href="https://pyo3.rs/v0.15.0/types.html?highlight=gil#gil-lifetimes-mutability-and-python-object-types">GIL and mutability</a> w.r.t. PyO3.¬†<a href="#fnref:5" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>We could define the Python `dataclass <a href="https://depth-first.com/articles/2020/08/10/python-extensions-in-pure-rust-with-pyo3/">purely in Rust</a>, but I wanted to simulate the effect of adding Rust to an existing Python project, where maybe you don‚Äôt want to move a class definition to Rust.¬†<a href="#fnref:8" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Btw, what about PyPy? I didn‚Äôt try it because it still just <a href="https://scikit-learn.org/stable/faq.html#do-you-support-pypy">don‚Äôt seem ready</a> as a viable CPython alternative for data science.¬†<a href="#fnref:4" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p><a href="https://youtu.be/FnBPECrSC7o?t=1867">This talk</a> by Ron Minsky of Jane Street Capital has some really interesting examples of using algebraic data types to write more robust code (using OCaml in the context of securities trading).¬†<a href="#fnref:9" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>In Rust, variants of an enum aren‚Äôt actually types, so you can‚Äôt so something like <code class="highlighter-rouge">fn f(s: DnaNucleotide::A) {}</code>. You also can‚Äôt write polymorphic code with enums like so:</p>
      <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Nucleotide</span><span class="p">{</span>
    <span class="n">RnaNucleotide</span><span class="p">,</span>
    <span class="n">DnaNucleotide</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Nucleotide</span><span class="p">)</span> <span class="p">{</span><span class="n">s</span><span class="nf">.complement</span><span class="p">();}</span>
</code></pre></div>      </div>
      <p>even if all the variants in the enum implement a <code class="highlighter-rouge">.complement</code> method. Instead you have to do <a href="https://stackoverflow.com/questions/51188460/how-can-i-structure-destructure-an-enum-of-enums">some wrapper/destructuring stuff</a> (which is pretty messy) or you have to use <a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html">trait bounds</a> like so:</p>
      <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Nucleotide</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">complement</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Nucleotide</span><span class="p">)</span> <span class="p">{</span><span class="n">s</span><span class="nf">.complement</span><span class="p">();}</span>
</code></pre></div>      </div>
      <p><a href="#fnref:10" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>I ran into basically every problem listed in <a href="https://depth-first.com/articles/2020/06/22/returning-rust-iterators/">this post</a>.¬†<a href="#fnref:11" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
  </ol>
</div>


  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="cyniphile/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/programming/rust/biology/2021/12/01/biology-rust.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="links-wrapper">
          <nav class="site-nav"><a class="page-link" href="/blog/about/">About</a><a class="page-link" href="/blog/search/">Search</a><a class="page-link" href="/blog/subscribe/">Subscribe</a><a class="page-link" href="/blog/categories/">Topics</a></nav>
    </div>

  </div>

</footer>
</body>

</html>
